###############################################################################
#
# IAR C/C++ Compiler V9.30.3.3983 for 8051                25/Nov/2016  14:12:38
# Copyright 2004-2016 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Components\stack\zcl\zcl_general.c
#    Command line       =  
#        -f "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\Tools\CC2530DB\f8wRouter.cfg"
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
#        -DRTR_NWK) -f "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg"
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
#        -DREJOIN_POLL_RATE=440 -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=900000)
#        -f "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg"
#        "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Components\stack\zcl\zcl_general.c" -D SECURE=1 -D
#        TC_LINKKEY_JOIN -D HAL_UART=TRUE -D HAL_UART_DMA_RX_MAX=64 -D
#        HAL_PA_LNA_CC2592 -D NV_INIT -D NV_RESTORE -D MULTICAST_ENABLED=FALSE
#        -D ZCL_READ -D ZCL_WRITE -D ZCL_REPORT -D ZCL_BASIC -D ZCL_ON_OFF -D
#        ZCL_ELECTRICAL_MEASUREMENT -lC "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\RouterEB\List"
#        -lA "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\RouterEB\List"
#        --diag_suppress Pe001,Pa010 -o "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\RouterEB\Obj"
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -I "C:\Texas
#        Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\" -I
#        "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\Source\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\Source\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\ZMain\TI2530DB\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\..\..\Components\hal\include\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\..\..\Components\mac\include\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\..\..\Components\mac\high_level\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\..\..\Components\mt\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\..\..\Components\osal\include\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\..\..\Components\services\saddr\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\..\..\Components\services\sdata\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\..\..\Components\stack\af\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\..\..\Components\stack\nwk\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\..\..\Components\stack\sapi\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\..\..\Components\stack\sec\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\..\..\Components\stack\sys\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\..\..\Components\stack\zcl\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\..\..\Components\stack\zdo\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\..\..\Components\zmac\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\..\..\Components\zmac\f8w\"
#        -Ohz --require_prototypes
#    List file          =  
#        C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\RouterEB\List\zcl_general.lst
#    Object file        =  
#        C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\RouterEB\Obj\zcl_general.r51
#
###############################################################################

C:\Texas Instruments\Z-Stack Home 1.2.2a.44539\Components\stack\zcl\zcl_general.c
      1          /**************************************************************************************************
      2            Filename:       zcl_general.c
      3            Revised:        $Date: 2015-09-10 09:36:48 -0700 (Thu, 10 Sep 2015) $
      4            Revision:       $Revision: 44493 $
      5          
      6            Description:    Zigbee Cluster Library - General.  This application receives all
      7                            ZCL messages and initially parses them before passing to application.
      8          
      9          
     10            Copyright 2006-2015 Texas Instruments Incorporated. All rights reserved.
     11          
     12            IMPORTANT: Your use of this Software is limited to those specific rights
     13            granted under the terms of a software license agreement between the user
     14            who downloaded the software, his/her employer (which must be your employer)
     15            and Texas Instruments Incorporated (the "License"). You may not use this
     16            Software unless you agree to abide by the terms of the License. The License
     17            limits your use, and you acknowledge, that the Software may not be modified,
     18            copied or distributed unless embedded on a Texas Instruments microcontroller
     19            or used solely and exclusively in conjunction with a Texas Instruments radio
     20            frequency transceiver, which is integrated into your product. Other than for
     21            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     22            works of, modify, distribute, perform, display or sell this Software and/or
     23            its documentation for any purpose.
     24          
     25            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     26            PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     27            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     28            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     29            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     30            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     31            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     32            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     33            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     34            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     35            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     36          
     37            Should you have any questions regarding your right to use this Software,
     38            contact Texas Instruments Incorporated at www.TI.com.
     39          **************************************************************************************************/
     40          
     41          /*********************************************************************
     42           * INCLUDES
     43           */
     44          #include "ZComDef.h"
     45          #include "zcl.h"
     46          #include "zcl_general.h"
     47          //#include "ZDApp.h"
     48          #include "zcl_ezmode.h"
     49          
     50          #if defined ( INTER_PAN )
     51            #include "stub_aps.h"
     52          #endif
     53          
     54          /*********************************************************************
     55           * MACROS
     56           */
     57          #define locationTypeAbsolute( a )          ( (a) & LOCATION_TYPE_ABSOLUTE )
     58          #define locationType2D( a )                ( (a) & LOCATION_TYPE_2_D )
     59          #define locationTypeCoordinateSystem( a )  ( (a) & LOCATION_TYPE_COORDINATE_SYSTEM )
     60          
     61          #ifdef ZCL_SCENES
     62          #define zclGeneral_ScenesRemaingCapacity() ( ZCL_GEN_MAX_SCENES - zclGeneral_CountAllScenes() )
     63          #endif // ZCL_SCENES
     64          
     65          /*********************************************************************
     66           * CONSTANTS
     67           */
     68          
     69          /*********************************************************************
     70           * TYPEDEFS
     71           */
     72          typedef struct zclGenCBRec
     73          {
     74            struct zclGenCBRec        *next;
     75            uint8                     endpoint; // Used to link it into the endpoint descriptor
     76            zclGeneral_AppCallbacks_t *CBs;     // Pointer to Callback function
     77          } zclGenCBRec_t;
     78          
     79          typedef struct zclGenSceneItem
     80          {
     81            struct zclGenSceneItem    *next;
     82            uint8                     endpoint; // Used to link it into the endpoint descriptor
     83            zclGeneral_Scene_t        scene;    // Scene info
     84          } zclGenSceneItem_t;
     85          
     86          typedef struct zclGenAlarmItem
     87          {
     88            struct zclGenAlarmItem    *next;
     89            uint8                     endpoint; // Used to link it into the endpoint descriptor
     90            zclGeneral_Alarm_t        alarm;    // Alarm info
     91          } zclGenAlarmItem_t;
     92          
     93          // Scene NV types
     94          typedef struct
     95          {
     96            uint16                    numRecs;
     97          } nvGenScenesHdr_t;
     98          
     99          typedef struct zclGenSceneNVItem
    100          {
    101            uint8                     endpoint;
    102            zclGeneral_Scene_t        scene;
    103          } zclGenSceneNVItem_t;
    104          
    105          /*********************************************************************
    106           * GLOBAL VARIABLES
    107           */
    108          
    109          /*********************************************************************
    110           * GLOBAL FUNCTIONS
    111           */
    112          
    113          /*********************************************************************
    114           * LOCAL VARIABLES
    115           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    116          static zclGenCBRec_t *zclGenCBs = (zclGenCBRec_t *)NULL;
   \                     zclGenCBs:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    117          static uint8 zclGenPluginRegisted = FALSE;
   \                     zclGenPluginRegisted:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    118          
    119          #if defined( ZCL_SCENES )
    120            #if !defined ( ZCL_STANDALONE )
    121              static zclGenSceneItem_t *zclGenSceneTable = (zclGenSceneItem_t *)NULL;
    122            #endif
    123          #endif // ZCL_SCENES
    124          
    125          #ifdef ZCL_ALARMS
    126          static zclGenAlarmItem_t *zclGenAlarmTable = (zclGenAlarmItem_t *)NULL;
    127          #endif // ZCL_ALARMS
    128          
    129          /*********************************************************************
    130           * LOCAL FUNCTIONS
    131           */
    132          static ZStatus_t zclGeneral_HdlIncoming( zclIncoming_t *pInMsg );
    133          static ZStatus_t zclGeneral_HdlInSpecificCommands( zclIncoming_t *pInMsg );
    134          static zclGeneral_AppCallbacks_t *zclGeneral_FindCallbacks( uint8 endpoint );
    135          
    136          // Device Configuration and Installation clusters
    137          #ifdef ZCL_BASIC
    138          static ZStatus_t zclGeneral_ProcessInBasic( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    139          #endif // ZCL_BASIC
    140          
    141          #ifdef ZCL_IDENTIFY
    142          static ZStatus_t zclGeneral_ProcessInIdentity( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    143          #endif // ZCL_IDENTIFY
    144          
    145          // Groups and Scenes clusters
    146          #ifdef ZCL_GROUPS
    147          static ZStatus_t zclGeneral_ProcessInGroupsServer( zclIncoming_t *pInMsg );
    148          static ZStatus_t zclGeneral_ProcessInGroupsClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    149          static ZStatus_t zclGeneral_AddGroup( uint8 endPoint, aps_Group_t *group, uint8 *pData );
    150          #endif // ZCL_GROUPS
    151          
    152          #ifdef ZCL_SCENES
    153          static ZStatus_t zclGeneral_ProcessInScenesServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    154          static ZStatus_t zclGeneral_ProcessInScenesClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    155          #endif // ZCL_SCENES
    156          
    157          // On/Off and Level Control Configuration clusters
    158          #ifdef ZCL_ON_OFF
    159          static ZStatus_t zclGeneral_ProcessInOnOff( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    160          #endif // ZCL_ONOFF
    161          
    162          #ifdef ZCL_LEVEL_CTRL
    163          static ZStatus_t zclGeneral_ProcessInLevelControl( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    164          #endif // ZCL_LEVEL_CTRL
    165          
    166          // Alarms cluster
    167          #ifdef ZCL_ALARMS
    168          static ZStatus_t zclGeneral_ProcessInAlarmsServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    169          static ZStatus_t zclGeneral_ProcessInAlarmsClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    170          #endif // ZCL_ALARMS
    171          
    172          // Location cluster
    173          #ifdef ZCL_LOCATION
    174          static ZStatus_t zclGeneral_ProcessInLocationServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    175          static ZStatus_t zclGeneral_ProcessInLocationClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    176          #endif // ZCL_LOCATION
    177          
    178          #ifdef ZCL_SCENES
    179            #if !defined ( ZCL_STANDALONE )
    180              static uint8 zclGeneral_ScenesInitNV( void );
    181              static void zclGeneral_ScenesSetDefaultNV( void );
    182              static void zclGeneral_ScenesWriteNV( void );
    183              static uint16 zclGeneral_ScenesRestoreFromNV( void );
    184            #endif
    185          #endif // ZCL_SCENES
    186          
    187          /*********************************************************************
    188           * @fn      zclGeneral_RegisterCmdCallbacks
    189           *
    190           * @brief   Register an applications command callbacks
    191           *
    192           * @param   endpoint - application's endpoint
    193           * @param   callbacks - pointer to the callback record.
    194           *
    195           * @return  ZMemError if not able to allocate
    196           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    197          ZStatus_t zclGeneral_RegisterCmdCallbacks( uint8 endpoint, zclGeneral_AppCallbacks_t *callbacks )
   \                     zclGeneral_RegisterCmdCallbacks:
    198          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0,R1
   \   000007   EA           MOV     A,R2
   \   000008   FE           MOV     R6,A
   \   000009   EB           MOV     A,R3
   \   00000A   FF           MOV     R7,A
    199            zclGenCBRec_t *pNewItem;
    200            zclGenCBRec_t *pLoop;
    201          
    202            // Register as a ZCL Plugin
    203            if ( zclGenPluginRegisted == FALSE )
   \   00000B   90....       MOV     DPTR,#zclGenPluginRegisted
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   7021         JNZ     ??zclGeneral_RegisterCmdCallbacks_0
    204            {
    205              zcl_registerPlugin( ZCL_CLUSTER_ID_GEN_BASIC,
    206                                  ZCL_CLUSTER_ID_GEN_MULTISTATE_VALUE_BASIC,
    207                                  zclGeneral_HdlIncoming );
   \   000011                ; Setup parameters for call to function zcl_registerPlugin
   \   000011   75....       MOV     ?V2,#`??zclGeneral_HdlIncoming::?relay` & 0xff
   \   000014   75....       MOV     ?V3,#(`??zclGeneral_HdlIncoming::?relay` >> 8) & 0xff
   \   000017   78..         MOV     R0,#?V2
   \   000019   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00001C   7C14         MOV     R4,#0x14
   \   00001E   7D00         MOV     R5,#0x0
   \   000020   7A00         MOV     R2,#0x0
   \   000022   7B00         MOV     R3,#0x0
   \   000024   12....       LCALL   `??zcl_registerPlugin::?relay`; Banked call to: zcl_registerPlugin
   \   000027   7402         MOV     A,#0x2
   \   000029   12....       LCALL   ?DEALLOC_XSTACK8
    208          
    209          #ifdef ZCL_SCENES
    210              // Initialize the Scenes Table
    211              zclGeneral_ScenesInit();
    212          #endif // ZCL_SCENES
    213          
    214              zclGenPluginRegisted = TRUE;
   \   00002C   90....       MOV     DPTR,#zclGenPluginRegisted
   \   00002F   7401         MOV     A,#0x1
   \   000031   F0           MOVX    @DPTR,A
    215            }
    216          
    217            // Fill in the new profile list
    218            pNewItem = zcl_mem_alloc( sizeof( zclGenCBRec_t ) );
   \                     ??zclGeneral_RegisterCmdCallbacks_0:
   \   000032                ; Setup parameters for call to function osal_mem_alloc
   \   000032   7A05         MOV     R2,#0x5
   \   000034   7B00         MOV     R3,#0x0
   \   000036   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000039   8A..         MOV     ?V2,R2
   \   00003B   8B..         MOV     ?V3,R3
   \   00003D   A8..         MOV     R0,?V2
   \   00003F   A9..         MOV     R1,?V3
    219            if ( pNewItem == NULL )
   \   000041   E8           MOV     A,R0
   \   000042   49           ORL     A,R1
   \   000043   7004         JNZ     ??zclGeneral_RegisterCmdCallbacks_1
    220              return (ZMemError);
   \   000045   7910         MOV     R1,#0x10
   \   000047   804E         SJMP    ??zclGeneral_RegisterCmdCallbacks_2
    221          
    222            pNewItem->next = (zclGenCBRec_t *)NULL;
   \                     ??zclGeneral_RegisterCmdCallbacks_1:
   \   000049   8882         MOV     DPL,R0
   \   00004B   8983         MOV     DPH,R1
   \   00004D   E4           CLR     A
   \   00004E   F0           MOVX    @DPTR,A
   \   00004F   A3           INC     DPTR
   \   000050   F0           MOVX    @DPTR,A
    223            pNewItem->endpoint = endpoint;
   \   000051   8882         MOV     DPL,R0
   \   000053   8983         MOV     DPH,R1
   \   000055   A3           INC     DPTR
   \   000056   A3           INC     DPTR
   \   000057   E5..         MOV     A,?V0
   \   000059   F0           MOVX    @DPTR,A
    224            pNewItem->CBs = callbacks;
   \   00005A   8882         MOV     DPL,R0
   \   00005C   8983         MOV     DPH,R1
   \   00005E   A3           INC     DPTR
   \   00005F   A3           INC     DPTR
   \   000060   A3           INC     DPTR
   \   000061   EE           MOV     A,R6
   \   000062   F0           MOVX    @DPTR,A
   \   000063   A3           INC     DPTR
   \   000064   EF           MOV     A,R7
   \   000065   F0           MOVX    @DPTR,A
    225          
    226            // Find spot in list
    227            if (  zclGenCBs == NULL )
   \   000066   90....       MOV     DPTR,#zclGenCBs
   \   000069   E0           MOVX    A,@DPTR
   \   00006A   FA           MOV     R2,A
   \   00006B   A3           INC     DPTR
   \   00006C   E0           MOVX    A,@DPTR
   \   00006D   FB           MOV     R3,A
   \   00006E   EA           MOV     A,R2
   \   00006F   4B           ORL     A,R3
   \   000070   90....       MOV     DPTR,#zclGenCBs
   \   000073   601B         JZ      ??zclGeneral_RegisterCmdCallbacks_3
    228            {
    229              zclGenCBs = pNewItem;
    230            }
    231            else
    232            {
    233              // Look for end of list
    234              pLoop = zclGenCBs;
   \   000075   E0           MOVX    A,@DPTR
   \   000076   FC           MOV     R4,A
   \   000077   A3           INC     DPTR
   \   000078   E0           MOVX    A,@DPTR
   \   000079   8003         SJMP    ??zclGeneral_RegisterCmdCallbacks_4
    235              while ( pLoop->next != NULL )
    236                pLoop = pLoop->next;
   \                     ??zclGeneral_RegisterCmdCallbacks_5:
   \   00007B   EA           MOV     A,R2
   \   00007C   FC           MOV     R4,A
   \   00007D   EB           MOV     A,R3
   \                     ??zclGeneral_RegisterCmdCallbacks_4:
   \   00007E   FD           MOV     R5,A
   \   00007F   8C82         MOV     DPL,R4
   \   000081   8D83         MOV     DPH,R5
   \   000083   E0           MOVX    A,@DPTR
   \   000084   FA           MOV     R2,A
   \   000085   A3           INC     DPTR
   \   000086   E0           MOVX    A,@DPTR
   \   000087   FB           MOV     R3,A
   \   000088   EA           MOV     A,R2
   \   000089   4B           ORL     A,R3
   \   00008A   70EF         JNZ     ??zclGeneral_RegisterCmdCallbacks_5
    237          
    238              // Put new item at end of list
    239              pLoop->next = pNewItem;
   \   00008C   8C82         MOV     DPL,R4
   \   00008E   8D83         MOV     DPH,R5
   \                     ??zclGeneral_RegisterCmdCallbacks_3:
   \   000090   E8           MOV     A,R0
   \   000091   F0           MOVX    @DPTR,A
   \   000092   A3           INC     DPTR
   \   000093   E9           MOV     A,R1
   \   000094   F0           MOVX    @DPTR,A
    240            }
    241          
    242            return ( ZSuccess );
   \   000095   7900         MOV     R1,#0x0
   \                     ??zclGeneral_RegisterCmdCallbacks_2:
   \   000097   7F04         MOV     R7,#0x4
   \   000099   02....       LJMP    ?BANKED_LEAVE_XDATA
    243          }
    244          
    245          #ifdef ZCL_IDENTIFY
    246          /*********************************************************************
    247           * @fn      zclGeneral_SendIdentify
    248           *
    249           * @brief   Call to send out an Identify Command
    250           *
    251           * @param   srcEP - Sending application's endpoint
    252           * @param   dstAddr - where you want the message to go
    253           * @param   identifyTime - how long the device will continue to identify itself (in seconds)
    254           * @param   seqNum - identification number for the transaction
    255           *
    256           * @return  ZStatus_t
    257           */
    258          ZStatus_t zclGeneral_SendIdentify( uint8 srcEP, afAddrType_t *dstAddr,
    259                                             uint16 identifyTime, uint8 disableDefaultRsp, uint8 seqNum )
    260          {
    261            uint8 buf[2];
    262          
    263            buf[0] = LO_UINT16( identifyTime );
    264            buf[1] = HI_UINT16( identifyTime );
    265          
    266            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
    267                                    COMMAND_IDENTIFY, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    268                                    disableDefaultRsp, 0, seqNum, 2, buf );
    269          }
    270          
    271          /*********************************************************************
    272           * @fn      zclGeneral_SendIdentifyEZModeInvoke
    273           *
    274           * @brief   Call to send out an Identify EZ-Mode Invoke Command
    275           *
    276           * @param   srcEP - Sending application's endpoint
    277           * @param   dstAddr - where you want the message to go
    278           * @param   action - describes the EZ-Mode action to be performed
    279           * @param   seqNum - identification number for the transaction
    280           *
    281           * @return  ZStatus_t
    282           */
    283          ZStatus_t zclGeneral_SendIdentifyEZModeInvoke( uint8 srcEP, afAddrType_t *dstAddr,
    284                                                         uint8 action, uint8 disableDefaultRsp, uint8 seqNum )
    285          {
    286            uint8 buf[1];
    287          
    288            buf[0] = action;
    289          
    290            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
    291                                    COMMAND_IDENTIFY_EZMODE_INVOKE, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    292                                    disableDefaultRsp, 0, seqNum, 1, buf );
    293          }
    294          
    295          /*********************************************************************
    296           * @fn      zclGeneral_SendIdentifyUpdateCommState
    297           *
    298           * @brief   Call to send out an Identify Update Commission State Command
    299           *
    300           * @param   srcEP - Sending application's endpoint
    301           * @param   dstAddr - where you want the message to go
    302           * @param   action - describes the EZ-Mode action to be performed
    303           * @param   commissionStateMask - updates the device's commission state
    304           * @param   seqNum - identification number for the transaction
    305           *
    306           * @return  ZStatus_t
    307           */
    308          ZStatus_t zclGeneral_SendIdentifyUpdateCommState( uint8 srcEP, afAddrType_t *dstAddr,
    309                                                            uint8 action, uint8 commissionStateMask,
    310                                                            uint8 disableDefaultRsp, uint8 seqNum )
    311          {
    312            uint8 buf[2];
    313          
    314            buf[0] = action;
    315            buf[1] = commissionStateMask;
    316          
    317            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
    318                                    COMMAND_IDENTIFY_UPDATE_COMMISSION_STATE, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    319                                    disableDefaultRsp, 0, seqNum, 2, buf );
    320          }
    321          
    322          #ifdef ZCL_LIGHT_LINK_ENHANCE
    323          /*********************************************************************
    324           * @fn      zclGeneral_SendIdentifyTriggerEffect
    325           *
    326           * @brief   Call to send out a Trigger Effect Command
    327           *
    328           * @param   srcEP - Sending application's endpoint
    329           * @param   dstAddr - where you want the message to go
    330           * @param   effectId - identify effect to use
    331           * @param   effectVariant - which variant of effect to be triggered
    332           * @param   disableDefaultRsp - whether to disable the Default Response command
    333           * @param   seqNum - identification number for the transaction
    334           *
    335           * @return  ZStatus_t
    336           */
    337          ZStatus_t zclGeneral_SendIdentifyTriggerEffect( uint8 srcEP, afAddrType_t *dstAddr,
    338                                                          uint8 effectId, uint8 effectVariant,
    339                                                          uint8 disableDefaultRsp, uint8 seqNum )
    340          {
    341            uint8 buf[2];
    342          
    343            buf[0] = effectId;
    344            buf[1] = effectVariant;
    345          
    346            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
    347                                    COMMAND_IDENTIFY_TRIGGER_EFFECT, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    348                                    disableDefaultRsp, 0, seqNum, 2, buf );
    349          }
    350          #endif // ZCL_LIGHT_LINK_ENHANCE
    351          
    352          /*********************************************************************
    353           * @fn      zclGeneral_SendIdentifyQueryResponse
    354           *
    355           * @brief   Call to send out an Identify Query Response Command
    356           *
    357           * @param   srcEP - Sending application's endpoint
    358           * @param   dstAddr - where you want the message to go
    359           * @param   timeout - how long the device will continue to identify itself (in seconds)
    360           * @param   seqNum - identification number for the transaction
    361           *
    362           * @return  ZStatus_t
    363           */
    364          ZStatus_t zclGeneral_SendIdentifyQueryResponse( uint8 srcEP, afAddrType_t *dstAddr,
    365                                                          uint16 timeout, uint8 disableDefaultRsp, uint8 seqNum )
    366          {
    367            uint8 buf[2];
    368          
    369            buf[0] = LO_UINT16( timeout );
    370            buf[1] = HI_UINT16( timeout );
    371          
    372            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
    373                                    COMMAND_IDENTIFY_QUERY_RSP, TRUE,
    374                                    ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, 2, buf );
    375          }
    376          #endif // ZCL_IDENTIFY
    377          
    378          #ifdef ZCL_GROUPS
    379          /*********************************************************************
    380           * @fn      zclGeneral_SendGroupRequest
    381           *
    382           * @brief   Send a Group Request to a device.  You can also use the
    383           *          appropriate macro.
    384           *
    385           * @param   srcEP - Sending Apps endpoint
    386           * @param   dstAddr - where to send the request
    387           * @param   cmd - one of the following:
    388           *              COMMAND_GROUP_VIEW
    389           *              COMMAND_GROUP_REMOVE
    390           * @param   groupID -
    391           *
    392           * @return  ZStatus_t
    393           */
    394          ZStatus_t zclGeneral_SendGroupRequest( uint8 srcEP, afAddrType_t *dstAddr,
    395                                                 uint8 cmd, uint16 groupID, uint8 disableDefaultRsp, uint8 seqNum )
    396          {
    397            uint8 buf[2];
    398          
    399            buf[0] = LO_UINT16( groupID );
    400            buf[1] = HI_UINT16( groupID );
    401          
    402            return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    403                                      cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    404                                      disableDefaultRsp, 0, seqNum, 2, buf ) );
    405          }
    406          
    407          /*********************************************************************
    408           * @fn      zclGeneral_SendAddGroupRequest
    409           *
    410           * @brief   Send the Add Group Request to a device
    411           *
    412           * @param   srcEP - Sending Apps endpoint
    413           * @param   dstAddr - where to send the request
    414           * @param   cmd - one of the following:
    415           *                COMMAND_GROUP_ADD
    416           *                COMMAND_GROUP_ADD_IF_IDENTIFYING
    417           * @param   groupID - pointer to the group structure
    418           * @param   groupName - pointer to Group Name.  This is a Zigbee
    419           *          string data type, so the first byte is the length of the
    420           *          name (in bytes), then the name.
    421           *
    422           * @return  ZStatus_t
    423           */
    424          ZStatus_t zclGeneral_SendAddGroupRequest( uint8 srcEP, afAddrType_t *dstAddr,
    425                                                    uint8 cmd, uint16 groupID, uint8 *groupName,
    426                                                    uint8 disableDefaultRsp, uint8 seqNum )
    427          {
    428            uint8 *buf;
    429            uint8 *pBuf;
    430            uint8 len;
    431            ZStatus_t status;
    432          
    433            len = 2;    // Group ID
    434            len += groupName[0] + 1;  // String + 1 for length
    435          
    436            buf = zcl_mem_alloc( len );
    437            if ( buf )
    438            {
    439              pBuf = buf;
    440              *pBuf++ = LO_UINT16( groupID );
    441              *pBuf++ = HI_UINT16( groupID );
    442              *pBuf++ = groupName[0]; // string length
    443              zcl_memcpy( pBuf, &(groupName[1]), groupName[0] );
    444          
    445              status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    446                                        cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    447                                        disableDefaultRsp, 0, seqNum, len, buf );
    448              zcl_mem_free( buf );
    449            }
    450            else
    451              status = ZMemError;
    452          
    453            return ( status );
    454          }
    455          
    456          /*********************************************************************
    457           * @fn      zclGeneral_SendGroupGetMembershipRequest
    458           *
    459           * @brief   Send a Get Group Membership (Resposne) Command to a device
    460           *
    461           * @param   srcEP - Sending Apps endpoint
    462           * @param   dstAddr - where to send the request
    463           * @param   cmd - one of the following:
    464           *                COMMAND_GROUP_GET_MEMBERSHIP
    465           *                COMMAND_GROUP_GET_MEMBERSHIP_RSP
    466           * @param   groupID - pointer to the group structure
    467           * @param   groupName - pointer to Group Name.  This is a Zigbee
    468           *          string data type, so the first byte is the length of the
    469           *          name (in bytes), then the name.
    470           *
    471           * @return  ZStatus_t
    472           */
    473          ZStatus_t zclGeneral_SendGroupGetMembershipRequest( uint8 srcEP, afAddrType_t *dstAddr,
    474                                                              uint8 cmd, uint8 rspCmd, uint8 direction, uint8 capacity,
    475                                                              uint8 grpCnt, uint16 *grpList, uint8 disableDefaultRsp, uint8 seqNum )
    476          {
    477            uint8 *buf;
    478            uint8 *pBuf;
    479            uint8 len = 0;
    480            uint8 i;
    481            ZStatus_t status;
    482          
    483            if ( rspCmd )
    484              len++;  // Capacity
    485          
    486            len++;  // Group Count
    487            len += sizeof ( uint16 ) * grpCnt;  // Group List
    488          
    489            buf = zcl_mem_alloc( len );
    490            if ( buf )
    491            {
    492              pBuf = buf;
    493              if ( rspCmd )
    494                *pBuf++ = capacity;
    495          
    496              *pBuf++ = grpCnt;
    497              for ( i = 0; i < grpCnt; i++ )
    498              {
    499                *pBuf++ = LO_UINT16( grpList[i] );
    500                *pBuf++ = HI_UINT16( grpList[i] );
    501              }
    502          
    503              status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    504                                        cmd, TRUE, direction,
    505                                        disableDefaultRsp, 0, seqNum, len, buf );
    506              zcl_mem_free( buf );
    507            }
    508            else
    509              status = ZMemError;
    510          
    511            return ( status );
    512          }
    513          
    514          /*********************************************************************
    515           * @fn      zclGeneral_SendGroupResponse
    516           *
    517           * @brief   Send Group Response (not Group View Response)
    518           *
    519           * @param   srcEP - Sending application's endpoint
    520           * @param   dstAddr - where you want the message to go
    521           * @param   cmd - either COMMAND_GROUP_ADD_RSP or COMMAND_GROUP_REMOVE_RSP
    522           * @param   status - group command status
    523           * @param   groupID - what group
    524           *
    525           * @return  ZStatus_t
    526           */
    527          ZStatus_t zclGeneral_SendGroupResponse( uint8 srcEP, afAddrType_t *dstAddr,
    528                                                  uint8 cmd, uint8 status, uint16 groupID,
    529                                                  uint8 disableDefaultRsp, uint8 seqNum )
    530          {
    531            uint8 buf[3];
    532          
    533            buf[0] = status;
    534            buf[1] = LO_UINT16( groupID );
    535            buf[2] = HI_UINT16( groupID );
    536          
    537            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    538                                    cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    539                                    disableDefaultRsp, 0, seqNum, 3, buf );
    540          }
    541          
    542          /*********************************************************************
    543           * @fn      zclGeneral_SendGroupViewResponse
    544           *
    545           * @brief   Call to send Group Response Command
    546           *
    547           * @param   srcEP - Sending application's endpoint
    548           * @param   dstAddr - where you want the message to go
    549           * @param   cmd - either COMMAND_GROUP_ADD_RSP or COMMAND_GROUP_REMOVE_RSP
    550           * @param   status - group command status
    551           * @param   grp - group info
    552           *
    553           * @return  ZStatus_t
    554           */
    555          ZStatus_t zclGeneral_SendGroupViewResponse( uint8 srcEP, afAddrType_t *dstAddr,
    556                                                      uint8 status, aps_Group_t *grp, uint8 disableDefaultRsp, uint8 seqNum )
    557          {
    558            uint8 *buf;
    559            uint8 len;
    560            ZStatus_t stat;
    561          
    562            len = 1 + 2 + 1; // Status + Group ID + name length
    563          
    564            if ( status == ZCL_STATUS_SUCCESS )
    565            {
    566              len += grp->name[0];  // String length
    567            }
    568          
    569            buf = zcl_mem_alloc( len );
    570            if ( buf )
    571            {
    572              buf[0] = status;
    573              buf[1] = LO_UINT16( grp->ID );
    574              buf[2] = HI_UINT16( grp->ID );
    575          
    576              if ( status == ZCL_STATUS_SUCCESS )
    577              {
    578                buf[3] = grp->name[0]; // string length
    579                zcl_memcpy( &buf[4], (&grp->name[1]), grp->name[0] );
    580              }
    581              else //ZCL_STATUS_NOT_FOUND
    582              {
    583                buf[3] = 0;
    584              }
    585          
    586              stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    587                                      COMMAND_GROUP_VIEW_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    588                                      disableDefaultRsp, 0, seqNum, len, buf );
    589              zcl_mem_free( buf );
    590            }
    591            else
    592            {
    593              stat = ZMemError;
    594            }
    595          
    596            return ( stat );
    597          }
    598          #endif // ZCL_GROUPS
    599          
    600          #ifdef ZCL_SCENES
    601          /*********************************************************************
    602           * @fn      zclGeneral_SendAddSceneRequest
    603           *
    604           * @brief   Send the (Enhanced) Add Scene Request to a device. You can
    605           *           also use the appropriate macro.
    606           *
    607           * @param   srcEP - Sending Apps endpoint
    608           * @param   dstAddr - where to send the request
    609           * @param   scene - pointer to the scene structure
    610           * @param  cmd - COMMAND_SCENE_ADD or COMMAND_SCENE_ENHANCED_ADD
    611           * @param   disableDefaultRsp - whether to disable the Default Response command
    612           * @param   seqNum - sequence number
    613           *
    614           * @return  ZStatus_t
    615           */
    616          ZStatus_t zclGeneral_SendAddSceneRequest( uint8 srcEP, afAddrType_t *dstAddr,
    617                                                    uint8 cmd, zclGeneral_Scene_t *scene,
    618                                                    uint8 disableDefaultRsp, uint8 seqNum )
    619          {
    620            uint8 *buf;
    621            uint8 *pBuf;
    622            uint8 len;
    623            ZStatus_t status;
    624          
    625            len = 2 + 1 + 2;    // Group ID + Scene ID + transition time
    626            len += scene->name[0] + 1; // String + 1 for length
    627          
    628            // Add something for the extension field length
    629            len += scene->extLen;
    630          
    631            buf = zcl_mem_alloc( len );
    632            if ( buf )
    633            {
    634              pBuf = buf;
    635              *pBuf++ = LO_UINT16( scene->groupID );
    636              *pBuf++ = HI_UINT16( scene->groupID );
    637              *pBuf++ = scene->ID;
    638              *pBuf++ = LO_UINT16( scene->transTime );
    639              *pBuf++ = HI_UINT16( scene->transTime );
    640              *pBuf++ = scene->name[0]; // string length
    641              zcl_memcpy( pBuf, &(scene->name[1]), scene->name[0] );
    642              pBuf += scene->name[0]; // move pass name
    643          
    644              // Add the extension fields
    645              if ( scene->extLen > 0 )
    646                zcl_memcpy( pBuf, scene->extField, scene->extLen );
    647          
    648              status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    649                                        cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    650                                        disableDefaultRsp, 0, seqNum, len, buf );
    651              zcl_mem_free( buf );
    652            }
    653            else
    654              status = ZMemError;
    655          
    656            return ( status );
    657          }
    658          
    659          /*********************************************************************
    660           * @fn      zclGeneral_SendSceneRequest
    661           *
    662           * @brief   Send a Scene Request to a device.  You can also use the
    663           *          appropriate macro.
    664           *
    665           * @param   srcEP - Sending Apps endpoint
    666           * @param   dstAddr - where to send the request
    667           * @param   cmd - one of the following:
    668           *              COMMAND_SCENE_VIEW
    669           *              COMMAND_SCENE_REMOVE
    670           *              COMMAND_SCENE_REMOVE_ALL
    671           *              COMMAND_SCENE_STORE
    672           *              COMMAND_SCENE_RECALL
    673           *              COMMAND_SCENE_GET_MEMBERSHIP
    674           *              COMMAND_SCENE_ENHANCED_VIEW
    675           * @param   groupID - group ID
    676           * @param   sceneID - scene ID (not applicable to COMMAND_SCENE_REMOVE_ALL and
    677           *                    COMMAND_SCENE_GET_MEMBERSHIP)
    678           * @param   disableDefaultRsp - whether to disable the Default Response command
    679           * @param   seqNum - sequence number
    680           * @return  ZStatus_t
    681           */
    682          ZStatus_t zclGeneral_SendSceneRequest( uint8 srcEP, afAddrType_t *dstAddr,
    683                                                 uint8 cmd, uint16 groupID, uint8 sceneID,
    684                                                 uint8 disableDefaultRsp, uint8 seqNum )
    685          {
    686            uint8 buf[3];
    687            uint8 len = 2;
    688          
    689            buf[0] = LO_UINT16( groupID );
    690            buf[1] = HI_UINT16( groupID );
    691          
    692            if ( cmd != COMMAND_SCENE_REMOVE_ALL && cmd != COMMAND_SCENE_GET_MEMBERSHIP )
    693            {
    694              buf[2] = sceneID;
    695              len++;
    696            }
    697          
    698            return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    699                                      cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    700                                      disableDefaultRsp, 0, seqNum, len, buf ) );
    701          }
    702          
    703          /*********************************************************************
    704           * @fn      zclGeneral_SendSceneResponse
    705           *
    706           * @brief   Send Group Response (not Group View Response)
    707           *
    708           * @param   srcEP - Sending application's endpoint
    709           * @param   dstAddr - where you want the message to go
    710           * @param   cmd - either COMMAND_SCENE_ADD_RSP, COMMAND_SCENE_REMOVE_RSP
    711           *                COMMAND_SCENE_STORE_RSP, or COMMAND_SCENE_REMOVE_ALL_RSP
    712           * @param   status - scene command status
    713           * @param   groupID - what group
    714           * @param   sceneID - what scene (not applicable to COMMAND_SCENE_REMOVE_ALL_RSP)
    715           *
    716           * @return  ZStatus_t
    717           */
    718          ZStatus_t zclGeneral_SendSceneResponse( uint8 srcEP, afAddrType_t *dstAddr,
    719                                                  uint8 cmd, uint8 status, uint16 groupID,
    720                                                  uint8 sceneID, uint8 disableDefaultRsp, uint8 seqNum )
    721          {
    722            uint8 buf[4];
    723            uint8 len = 1 + 2; // Status + Group ID
    724          
    725            buf[0] = status;
    726            buf[1] = LO_UINT16( groupID );
    727            buf[2] = HI_UINT16( groupID );
    728          
    729            if ( cmd != COMMAND_SCENE_REMOVE_ALL_RSP )
    730            {
    731              buf[3] = sceneID;
    732              len++;
    733            }
    734          
    735            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    736                                    cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    737                                    disableDefaultRsp, 0, seqNum, len, buf );
    738          }
    739          
    740          /*********************************************************************
    741           * @fn      zclGeneral_SendSceneViewResponse
    742           *
    743           * @brief   Call to send Scene (Enahced) View Response Command. You can
    744           *           also use the appropriate macro.
    745           *
    746           * @param   srcEP - Sending application's endpoint
    747           * @param   dstAddr - where you want the message to go
    748           * @param   cmd - either COMMAND_SCENE_VIEW_RSP or COMMAND_SCENE_ENHANCED_VIEW_RSP
    749           * @param   status - scene command status
    750           * @param   scene - scene info
    751           *
    752           * @return  ZStatus_t
    753           */
    754          ZStatus_t zclGeneral_SendSceneViewRsp( uint8 srcEP, afAddrType_t *dstAddr,
    755                                                 uint8 cmd, uint8 status, zclGeneral_Scene_t *scene,
    756                                                 uint8 disableDefaultRsp, uint8 seqNum )
    757          {
    758            uint8 *buf;
    759            uint8 *pBuf;
    760            uint8 len = 1 + 2 + 1; // Status + Group ID + Scene ID
    761            ZStatus_t stat;
    762          
    763            if ( status == ZCL_STATUS_SUCCESS )
    764            {
    765              len += 2; // Transition Time
    766              len += scene->name[0] + 1; // string + 1 for length
    767          
    768              // Add something for the extension field length
    769              len += scene->extLen;
    770            }
    771          
    772            buf = zcl_mem_alloc( len );
    773            if ( buf )
    774            {
    775              pBuf = buf;
    776              *pBuf++ = status;
    777              *pBuf++ = LO_UINT16( scene->groupID );
    778              *pBuf++ = HI_UINT16( scene->groupID );
    779              *pBuf++ = scene->ID;
    780              if ( status == ZCL_STATUS_SUCCESS )
    781              {
    782                uint16 transTime = scene->transTime;
    783                if ( cmd == COMMAND_SCENE_ENHANCED_VIEW_RSP )
    784                {
    785                  // Transition time is in 1/10s
    786                  transTime *= 10;
    787                  transTime += scene->transTime100ms;
    788                }
    789          
    790                *pBuf++ = LO_UINT16( transTime );
    791                *pBuf++ = HI_UINT16( transTime );
    792                *pBuf++ = scene->name[0]; // string length
    793                if ( scene->name[0] != 0 )
    794                {
    795                  zcl_memcpy( pBuf, &(scene->name[1]), scene->name[0] );
    796                  pBuf += scene->name[0]; // move pass name
    797                }
    798          
    799                // Add the extension fields
    800                if ( scene->extLen > 0 )
    801                  zcl_memcpy( pBuf, scene->extField, scene->extLen );
    802              }
    803          
    804              stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    805                                      cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    806                                      disableDefaultRsp, 0, seqNum, len, buf );
    807              zcl_mem_free( buf );
    808            }
    809            else
    810              stat = ZMemError;
    811          
    812            return ( stat );
    813          }
    814          
    815          /*********************************************************************
    816           * @fn      zclGeneral_SendSceneGetMembershipResponse
    817           *
    818           * @brief   Call to send Scene Get Membership Response Command
    819           *
    820           * @param   srcEP - Sending application's endpoint
    821           * @param   dstAddr - where you want the message to go
    822           * @param   status - scene command status
    823           * @param   capacity - remaining capacity of the scene table
    824           * @param   sceneCnt - number of scenes in the scene list
    825           * @param   sceneList - list of scene IDs
    826           * @param   groupID - group ID that scene belongs to
    827           * @param   seqNum - sequence number
    828           *
    829           * @return  ZStatus_t
    830           */
    831          ZStatus_t zclGeneral_SendSceneGetMembershipResponse( uint8 srcEP, afAddrType_t *dstAddr,
    832                                                               uint8 status, uint8 capacity, uint8 sceneCnt, uint8 *sceneList,
    833                                                               uint16 groupID, uint8 disableDefaultRsp, uint8 seqNum )
    834          {
    835            uint8 *buf;
    836            uint8 *pBuf;
    837            uint8 len = 1 + 1 + 2; // Status + Capacity + Group ID;
    838            uint8 i;
    839            ZStatus_t stat;
    840          
    841            if ( status == ZCL_STATUS_SUCCESS )
    842            {
    843              len++; // Scene Count
    844              len += sceneCnt; // Scene List (Scene ID is a single octet)
    845            }
    846          
    847            buf = zcl_mem_alloc( len );
    848            if ( buf )
    849            {
    850              pBuf = buf;
    851              *pBuf++ = status;
    852              *pBuf++ = capacity;
    853              *pBuf++ = LO_UINT16( groupID );
    854              *pBuf++ = HI_UINT16( groupID );
    855              if ( status == ZCL_STATUS_SUCCESS )
    856              {
    857                *pBuf++ = sceneCnt;
    858                for ( i = 0; i < sceneCnt; i++ )
    859                  *pBuf++ = sceneList[i];
    860              }
    861          
    862              stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    863                                      COMMAND_SCENE_GET_MEMBERSHIP_RSP, TRUE,
    864                                      ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, len, buf );
    865              zcl_mem_free( buf );
    866            }
    867            else
    868              stat = ZMemError;
    869          
    870            return ( stat );
    871          }
    872          
    873          #ifdef ZCL_LIGHT_LINK_ENHANCE
    874          /*********************************************************************
    875           * @fn      zclGeneral_SendSceneCopy
    876           *
    877           * @brief   Send Scene Copy Request to a device
    878           *
    879           * @param   srcEP - sending application's endpoint
    880           * @param   dstAddr - where to send the request
    881           * @param   mode - how scene copy is to proceed
    882           * @param   groupIDFrom - group from which scene to be copied
    883           * @param   sceneIDFrom - scene from which scene to be copied
    884           * @param   groupIDTo - group to which scene to be copied
    885           * @param   sceneIDTo - scene to which scene to be copied
    886           * @param   disableDefaultRsp - disable Default Response command
    887           * @param   seqNum - the identification number for the transaction
    888           *
    889           * @return  ZStatus_t
    890           */
    891          ZStatus_t zclGeneral_SendSceneCopy( uint8 srcEP, afAddrType_t *dstAddr,
    892                                              uint8 mode, uint16 groupIDFrom, uint8 sceneIDFrom,
    893                                              uint16 groupIDTo, uint8 sceneIDTo,
    894                                              uint8 disableDefaultRsp, uint8 seqNum )
    895          {
    896            uint8 buf[7];
    897          
    898            buf[0] = mode;
    899            buf[1] = LO_UINT16( groupIDFrom );
    900            buf[2] = HI_UINT16( groupIDFrom );
    901            buf[3] = sceneIDFrom;
    902            buf[4] = LO_UINT16( groupIDTo );
    903            buf[5] = HI_UINT16( groupIDTo );
    904            buf[6] = sceneIDTo;
    905          
    906            return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    907                                      COMMAND_SCENE_COPY, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    908                                      disableDefaultRsp, 0, seqNum, 7, buf ) );
    909          }
    910          
    911          /*********************************************************************
    912           * @fn      zclGeneral_SendSceneCopyResponse
    913           *
    914           * @brief   Send Scene Copy Response to a device
    915           *
    916           * @param   srcEP - sending application's endpoint
    917           * @param   dstAddr - where to send the request
    918           * @param   status - status of copy scene attemp
    919           * @param   groupIDFrom - group from which scene was copied
    920           * @param   sceneIDFrom - scene from which scene was copied
    921           * @param   disableDefaultRsp - disable Default Response command
    922           * @param   seqNum - the identification number for the transaction
    923           *
    924           * @return  ZStatus_t
    925           */
    926          ZStatus_t zclGeneral_SendSceneCopyResponse( uint8 srcEP, afAddrType_t *dstAddr,
    927                                                      uint8 status, uint16 groupIDFrom, uint8 sceneIDFrom,
    928                                                      uint8 disableDefaultRsp, uint8 seqNum )
    929          {
    930            uint8 buf[4];
    931          
    932            buf[0] = status;
    933            buf[1] = LO_UINT16( groupIDFrom );
    934            buf[2] = HI_UINT16( groupIDFrom );
    935            buf[3] = sceneIDFrom;
    936          
    937            return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    938                                      COMMAND_SCENE_COPY_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    939                                      disableDefaultRsp, 0, seqNum, 4, buf ) );
    940          }
    941          #endif // ZCL_LIGHT_LINK_ENHANCE
    942          #endif // ZCL_SCENES
    943          
    944          #ifdef ZCL_ON_OFF
    945          #ifdef ZCL_LIGHT_LINK_ENHANCE
    946          /*********************************************************************
    947           * @fn      zclGeneral_SendOnOff_CmdOffWithEffect
    948           *
    949           * @brief   Call to send out an Off with Effect Command.
    950           *
    951           * @param   srcEP - Sending application's endpoint
    952           * @param   dstAddr - where you want the message to go
    953           * @param   effectId - fading effect to use when switching light off
    954           * @param   effectVariant - which variant of effect to be triggered
    955           * @param   disableDefaultRsp - whether to disable the Default Response command
    956           * @param   seqNum - sequence number
    957           *
    958           * @return  ZStatus_t
    959           */
    960          ZStatus_t zclGeneral_SendOnOff_CmdOffWithEffect( uint8 srcEP, afAddrType_t *dstAddr,
    961                                                           uint8 effectId, uint8 effectVariant,
    962                                                           uint8 disableDefaultRsp, uint8 seqNum )
    963          {
    964            uint8 buf[2];
    965          
    966            buf[0] = effectId;
    967            buf[1] = effectVariant;
    968          
    969            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ON_OFF,
    970                                    COMMAND_OFF_WITH_EFFECT, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    971                                    disableDefaultRsp, 0, seqNum, 2, buf );
    972          }
    973          
    974          /*********************************************************************
    975           * @fn      zclGeneral_SendOnOff_CmdOnWithTimedOff
    976           *
    977           * @brief   Call to send out an On with Timed Off Command.
    978           *
    979           * @param   srcEP - Sending application's endpoint
    980           * @param   dstAddr - where you want the message to go
    981           * @param   onOffCtrl - how the lamp is to be operated
    982           * @param   onTime - the length of time (in 1/10ths second) that the lamp is to remain on, before automatically turning off
    983           * @param   offWaitTime - the length of time (in 1/10ths second) that the lamp shall remain off, and guarded to prevent an on command turning the light back on.
    984           * @param   disableDefaultRsp - whether to disable the Default Response command
    985           * @param   seqNum - sequence number
    986           *
    987           * @return  ZStatus_t
    988           */
    989          ZStatus_t zclGeneral_SendOnOff_CmdOnWithTimedOff ( uint8 srcEP, afAddrType_t *dstAddr,
    990                                                             zclOnOffCtrl_t onOffCtrl, uint16 onTime, uint16 offWaitTime,
    991                                                             uint8 disableDefaultRsp, uint8 seqNum )
    992          {
    993            uint8 buf[5];
    994          
    995            buf[0] = onOffCtrl.byte;
    996            buf[1] = LO_UINT16( onTime );
    997            buf[2] = HI_UINT16( onTime );
    998            buf[3] = LO_UINT16( offWaitTime );
    999            buf[4] = HI_UINT16( offWaitTime );
   1000          
   1001            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ON_OFF,
   1002                                    COMMAND_ON_WITH_TIMED_OFF, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   1003                                    disableDefaultRsp, 0, seqNum, 5, buf );
   1004          }
   1005          #endif // ZCL_LIGHT_LINK_ENHANCE
   1006          #endif // ZCL_ON_OFF
   1007          
   1008          #ifdef ZCL_LEVEL_CTRL
   1009          /*********************************************************************
   1010           * @fn      zclGeneral_SendLevelControlMoveToLevelRequest
   1011           *
   1012           * @brief   Call to send out a Level Control Request. You can also use
   1013           *          the appropriate macro.
   1014           *
   1015           * @param   srcEP - Sending application's endpoint
   1016           * @param   dstAddr - where you want the message to go
   1017           * @param   cmd - one of the following:
   1018           *              COMMAND_LEVEL_MOVE_TO_LEVEL or
   1019           *              COMMAND_LEVEL_MOVE_TO_LEVEL_WITH_ON_OFF
   1020           * @param   level - what level to move to
   1021           * @param   transitionTime - how long to take to get to the level (in seconds)
   1022           *
   1023           * @return  ZStatus_t
   1024           */
   1025          ZStatus_t zclGeneral_SendLevelControlMoveToLevelRequest( uint8 srcEP, afAddrType_t *dstAddr,
   1026                                                                   uint8 cmd, uint8 level, uint16 transTime,
   1027                                                                   uint8 disableDefaultRsp, uint8 seqNum )
   1028          {
   1029            uint8 buf[3];
   1030          
   1031            buf[0] = level;
   1032            buf[1] = LO_UINT16( transTime );
   1033            buf[2] = HI_UINT16( transTime );
   1034          
   1035            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
   1036                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   1037                                    disableDefaultRsp, 0, seqNum, 3, buf );
   1038          }
   1039          
   1040          /*********************************************************************
   1041           * @fn      zclGeneral_SendLevelControlMoveRequest
   1042           *
   1043           * @brief   Call to send out a Level Control Request. You can also use
   1044           *          the appropriate macro.
   1045           *
   1046           * @param   srcEP - Sending application's endpoint
   1047           * @param   dstAddr - where you want the message to go
   1048           * @param   cmd - one of the following:
   1049           *              COMMAND_LEVEL_MOVE or
   1050           *              COMMAND_LEVEL_MOVE_WITH_ON_OFF
   1051           * @param   moveMode - LEVEL_MOVE_UP or
   1052           *                     LEVEL_MOVE_DOWN
   1053           * @param   rate - number of steps to take per second
   1054           *
   1055           * @return  ZStatus_t
   1056           */
   1057          ZStatus_t zclGeneral_SendLevelControlMoveRequest( uint8 srcEP, afAddrType_t *dstAddr,
   1058                                                            uint8 cmd, uint8 moveMode, uint8 rate,
   1059                                                            uint8 disableDefaultRsp, uint8 seqNum )
   1060          {
   1061            uint8 buf[2];
   1062          
   1063            buf[0] = moveMode;
   1064            buf[1] = rate;
   1065          
   1066            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
   1067                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   1068                                    disableDefaultRsp, 0, seqNum, 2, buf );
   1069          }
   1070          
   1071          /*********************************************************************
   1072           * @fn      zclGeneral_SendLevelControlStepRequest
   1073           *
   1074           * @brief   Call to send out a Level Control Request. You can also use
   1075           *          the appropriate macro.
   1076           *
   1077           * @param   srcEP - Sending application's endpoint
   1078           * @param   dstAddr - where you want the message to go
   1079           * @param   cmd - one of the following:
   1080           *              COMMAND_LEVEL_STEP
   1081           *              COMMAND_LEVEL_STEP_WITH_ON_OFF
   1082           * @param   stepMode - LEVEL_STEP_UP or
   1083           *                     LEVEL_STEP_DOWN
   1084           * @param   amount - number of levels to step
   1085           * @param   transitionTime - time, in 1/10ths of a second, to take to perform the step
   1086           *
   1087           * @return  ZStatus_t
   1088           */
   1089          ZStatus_t zclGeneral_SendLevelControlStepRequest( uint8 srcEP, afAddrType_t *dstAddr,
   1090                                                            uint8 cmd, uint8 stepMode, uint8 stepSize, uint16 transTime,
   1091                                                            uint8 disableDefaultRsp, uint8 seqNum )
   1092          {
   1093            uint8 buf[4];
   1094          
   1095            buf[0] = stepMode;
   1096            buf[1] = stepSize;
   1097            buf[2] = LO_UINT16( transTime );
   1098            buf[3] = HI_UINT16( transTime );
   1099          
   1100            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
   1101                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   1102                                    disableDefaultRsp, 0, seqNum, 4, buf );
   1103          }
   1104          
   1105          /*********************************************************************
   1106           * @fn      zclGeneral_SendLevelControlStepRequest
   1107           *
   1108           * @brief   Call to send out a Level Control Request. You can also use
   1109           *          the appropriate macro.
   1110           *
   1111           * @param   srcEP - Sending application's endpoint
   1112           * @param   dstAddr - where you want the message to go
   1113           * @param   cmd - one of the following:
   1114           *              COMMAND_LEVEL_STOP
   1115           *              COMMAND_LEVEL_STOP_WITH_ON_OFF
   1116           *
   1117           * @return  ZStatus_t
   1118           */
   1119          ZStatus_t zclGeneral_SendLevelControlStopRequest( uint8 srcEP, afAddrType_t *dstAddr, uint8 cmd,
   1120                                                            uint8 disableDefaultRsp, uint8 seqNum )
   1121          {
   1122            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
   1123                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   1124                                    disableDefaultRsp, 0, seqNum, 0, NULL );
   1125          }
   1126          #endif // ZCL_LEVEL_CTRL
   1127          
   1128          #ifdef ZCL_ALARMS
   1129          /*********************************************************************
   1130           * @fn      zclGeneral_SendAlarm
   1131           *
   1132           * @brief   Call to send out an Alarm Request Command
   1133           *
   1134           * @param   srcEP - Sending application's endpoint
   1135           * @param   dstAddr - where you want the message to go
   1136           * @param   cmd - COMMAND_ALARMS_ALARM
   1137           * @param   alarmCode - code for the cause of the alarm
   1138           * @param   clusterID - cluster whose attribute generate the alarm
   1139           *
   1140           * @return  ZStatus_t
   1141           */
   1142          ZStatus_t zclGeneral_SendAlarm( uint8 srcEP, afAddrType_t *dstAddr,
   1143                                          uint8 alarmCode, uint16 clusterID,
   1144                                          uint8 disableDefaultRsp, uint8 seqNum )
   1145          {
   1146            uint8 buf[3];
   1147          
   1148            buf[0] = alarmCode;
   1149            buf[1] = LO_UINT16( clusterID );
   1150            buf[2] = HI_UINT16( clusterID );
   1151          
   1152            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
   1153                                    COMMAND_ALARMS_ALARM, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
   1154                                    disableDefaultRsp, 0, seqNum, 3, buf );
   1155          }
   1156          
   1157          /*********************************************************************
   1158           * @fn      zclGeneral_SendAlarmReset
   1159           *
   1160           * @brief   Call to send out an Alarm Reset Command
   1161           *
   1162           * @param   srcEP - Sending application's endpoint
   1163           * @param   dstAddr - where you want the message to go
   1164           * @param   alarmCode - code for the cause of the alarm
   1165           * @param   clusterID - cluster whose attribute generate the alarm
   1166           *
   1167           * @return  ZStatus_t
   1168          */
   1169          ZStatus_t zclGeneral_SendAlarmReset( uint8 srcEP, afAddrType_t *dstAddr,
   1170                                               uint8 alarmCode, uint16 clusterID,
   1171                                               uint8 disableDefaultRsp, uint8 seqNum )
   1172          {
   1173            uint8 buf[3];
   1174          
   1175            buf[0] = alarmCode;
   1176            buf[1] = LO_UINT16( clusterID );
   1177            buf[2] = HI_UINT16( clusterID );
   1178          
   1179            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
   1180                                    COMMAND_ALARMS_RESET, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   1181                                    disableDefaultRsp, 0, seqNum, 3, buf );
   1182          }
   1183          
   1184          /*********************************************************************
   1185           * @fn      zclGeneral_SendAlarmGetResponse
   1186           *
   1187           * @brief   Call to send out an Alarm Get Response Command
   1188           *
   1189           * @param   srcEP - Sending application's endpoint
   1190           * @param   dstAddr - where you want the message to go
   1191           * @param   status - SUCCESS or NOT_FOUND
   1192           * @param   alarmCode - code for the cause of the alarm
   1193           * @param   clusterID - cluster whose attribute generate the alarm
   1194           * @param   timeStamp - time at which the alarm occured
   1195           *
   1196           * @return  ZStatus_t
   1197           */
   1198          ZStatus_t zclGeneral_SendAlarmGetResponse( uint8 srcEP, afAddrType_t *dstAddr,
   1199                                                     uint8 status, uint8 alarmCode, uint16 clusterID,
   1200                                                     uint32 timeStamp, uint8 disableDefaultRsp, uint8 seqNum )
   1201          {
   1202            uint8 buf[8];
   1203            uint8 len = 1; // Status
   1204          
   1205            buf[0] = status;
   1206            if ( status == ZCL_STATUS_SUCCESS )
   1207            {
   1208              len += 1 + 2 + 4; // Alarm code + Cluster ID + Time stamp
   1209              buf[1] = alarmCode;
   1210              buf[2] = LO_UINT16( clusterID );
   1211              buf[3] = HI_UINT16( clusterID );
   1212              zcl_buffer_uint32( &buf[4], timeStamp );
   1213            }
   1214          
   1215            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
   1216                                    COMMAND_ALARMS_GET_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
   1217                                    disableDefaultRsp, 0, seqNum, len, buf );
   1218          }
   1219          
   1220          #ifdef SE_UK_EXT
   1221          /*********************************************************************
   1222           * @fn      zclGeneral_SendAlarmGetEventLog
   1223           *
   1224           * @brief   Call to send out an Alarm Get Event Log Command
   1225           *
   1226           * @param   srcEP - Sending application's endpoint
   1227           * @param   dstAddr - where you want the message to go
   1228           * @param   pEventLog - pointer to Get Event Log Command
   1229           * @param   disableDefaultRsp - disable default response
   1230           * @param   seqNum - ZCL sequence number
   1231           *
   1232           * @return  ZStatus_t
   1233           */
   1234          ZStatus_t zclGeneral_SendAlarmGetEventLog( uint8 srcEP, afAddrType_t *dstAddr,
   1235                                                     zclGetEventLog_t *pEventLog,
   1236                                                     uint8 disableDefaultRsp, uint8 seqNum )
   1237          {
   1238            uint8 buf[10];
   1239          
   1240            buf[0] = pEventLog->logID;
   1241            zcl_buffer_uint32( &buf[1], pEventLog->startTime );
   1242            zcl_buffer_uint32( &buf[5], pEventLog->endTime );
   1243            buf[9] = pEventLog->numEvents;
   1244          
   1245            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
   1246                                    COMMAND_ALARMS_GET_EVENT_LOG, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
   1247                                    disableDefaultRsp, 0, seqNum, 10, buf );
   1248          }
   1249          
   1250          /*********************************************************************
   1251           * @fn      zclGeneral_SendAlarmPublishEventLog
   1252           *
   1253           * @brief   Call to send out an Alarm Publish Event Log Command
   1254           *
   1255           * @param   srcEP - Sending application's endpoint
   1256           * @param   dstAddr - where you want the message to go
   1257           * @param   pEventLog - pointer to Publish Event Log Command
   1258           * @param   disableDefaultRsp - disable default response
   1259           * @param   seqNum - ZCL sequence number
   1260           *
   1261           * @return  ZStatus_t
   1262           */
   1263          ZStatus_t zclGeneral_SendAlarmPublishEventLog( uint8 srcEP, afAddrType_t *dstAddr,
   1264                                                         zclPublishEventLog_t *pEventLog,
   1265                                                         uint8 disableDefaultRsp, uint8 seqNum )
   1266          {
   1267            uint8 *buf;
   1268            uint8 *pBuf;
   1269            uint8 bufLen;
   1270          
   1271            // Log ID + Command Index + Total Commands + (numSubLogs * ( Event ID + Event Time))
   1272            bufLen = 1 + 1 + 1 + (pEventLog->numSubLogs * (1 + 4));
   1273          
   1274            buf = zcl_mem_alloc( bufLen );
   1275            if ( buf == NULL )
   1276            {
   1277              return (ZMemError);
   1278            }
   1279          
   1280            pBuf = buf;
   1281            *pBuf++ = pEventLog->logID;
   1282            *pBuf++ = pEventLog->cmdIndex;
   1283            *pBuf++ = pEventLog->totalCmds;
   1284          
   1285            for ( uint8 i = 0; i < pEventLog->numSubLogs; i++ )
   1286            {
   1287              zclEventLogPayload_t *pLogs = &(pEventLog->pLogs[i]);
   1288          
   1289              *pBuf++ = pLogs->eventId;
   1290              pBuf = zcl_buffer_uint32( pBuf, pLogs->eventTime );
   1291            }
   1292          
   1293            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
   1294                                    COMMAND_ALARMS_PUBLISH_EVENT_LOG, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   1295                                    disableDefaultRsp, 0, seqNum, bufLen, buf );
   1296          }
   1297          #endif // SE_UK_EXT
   1298          #endif // ZCL_ALARMS
   1299          
   1300          #ifdef ZCL_LOCATION
   1301          /*********************************************************************
   1302           * @fn      zclGeneral_SendLocationSetAbsolute
   1303           *
   1304           * @brief   Call to send out a Set Absolute Location Command
   1305           *
   1306           * @param   srcEP - Sending application's endpoint
   1307           * @param   dstAddr - where you want the message to go
   1308           * @param   absLoc - absolute location info
   1309           *
   1310           * @return  ZStatus_t
   1311           */
   1312          ZStatus_t zclGeneral_SendLocationSetAbsolute( uint8 srcEP, afAddrType_t *dstAddr,
   1313                                                        zclLocationAbsolute_t *absLoc,
   1314                                                        uint8 disableDefaultRsp, uint8 seqNum )
   1315          {
   1316             uint8 buf[10]; // 5 fields (2 octects each)
   1317          
   1318             buf[0] = LO_UINT16( absLoc->coordinate1 );
   1319             buf[1] = HI_UINT16( absLoc->coordinate1 );
   1320             buf[2] = LO_UINT16( absLoc->coordinate2 );
   1321             buf[3] = HI_UINT16( absLoc->coordinate2 );
   1322             buf[4] = LO_UINT16( absLoc->coordinate3 );
   1323             buf[5] = HI_UINT16( absLoc->coordinate3 );
   1324             buf[6] = LO_UINT16( absLoc->power );
   1325             buf[7] = HI_UINT16( absLoc->power );
   1326             buf[8] = LO_UINT16( absLoc->pathLossExponent );
   1327             buf[9] = HI_UINT16( absLoc->pathLossExponent );
   1328          
   1329             return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1330                                     COMMAND_LOCATION_SET_ABSOLUTE, TRUE,
   1331                                     ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 10, buf );
   1332          }
   1333          
   1334          /*********************************************************************
   1335           * @fn      zclGeneral_SendLocationSetDevCfg
   1336           *
   1337           * @brief   Call to send out a Set Device Configuration Command
   1338           *
   1339           * @param   srcEP - Sending application's endpoint
   1340           * @param   dstAddr - where you want the message to go
   1341           * @param   devCfg - device configuration info
   1342           *
   1343           * @return  ZStatus_t
   1344           */
   1345          ZStatus_t zclGeneral_SendLocationSetDevCfg( uint8 srcEP, afAddrType_t *dstAddr,
   1346                                                      zclLocationDevCfg_t *devCfg,
   1347                                                      uint8 disableDefaultRsp, uint8 seqNum )
   1348          {
   1349             uint8 buf[9];  // 4 fields (2 octects each) + 1 field with 1 octect
   1350          
   1351             buf[0] = LO_UINT16( devCfg->power );
   1352             buf[1] = HI_UINT16( devCfg->power );
   1353             buf[2] = LO_UINT16( devCfg->pathLossExponent );
   1354             buf[3] = HI_UINT16( devCfg->pathLossExponent );
   1355             buf[4] = LO_UINT16( devCfg->calcPeriod );
   1356             buf[5] = HI_UINT16( devCfg->calcPeriod );
   1357             buf[6] = devCfg->numMeasurements;
   1358             buf[7] = LO_UINT16( devCfg->reportPeriod );
   1359             buf[8] = HI_UINT16( devCfg->reportPeriod );
   1360          
   1361             return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1362                                     COMMAND_LOCATION_SET_DEV_CFG, TRUE,
   1363                                     ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 9, buf );
   1364          }
   1365          
   1366          /*********************************************************************
   1367           * @fn      zclGeneral_SendLocationGetDevCfg
   1368           *
   1369           * @brief   Call to send out a Get Device Configuration Command
   1370           *
   1371           * @param   srcEP - Sending application's endpoint
   1372           * @param   dstAddr - where you want the message to go
   1373           * @param   targetAddr - device for which location parameters are being requested
   1374           *
   1375           * @return  ZStatus_t
   1376           */
   1377          ZStatus_t zclGeneral_SendLocationGetDevCfg( uint8 srcEP, afAddrType_t *dstAddr,
   1378                                                      uint8 *targetAddr, uint8 disableDefaultRsp, uint8 seqNum )
   1379          {
   1380            uint8 buf[8];
   1381          
   1382            zcl_memcpy( buf, targetAddr, 8 );
   1383          
   1384            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1385                                    COMMAND_LOCATION_GET_DEV_CFG, TRUE,
   1386                                    ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 8, buf );
   1387          }
   1388          
   1389          /*********************************************************************
   1390           * @fn      zclGeneral_SendLocationGetData
   1391           *
   1392           * @brief   Call to send out a Get Location Data Command
   1393           *
   1394           * @param   srcEP - Sending application's endpoint
   1395           * @param   dstAddr - where you want the message to go
   1396           * @param   locaData - location information and channel parameters that are requested.
   1397           *
   1398           * @return  ZStatus_t
   1399           */
   1400          ZStatus_t zclGeneral_SendLocationGetData( uint8 srcEP, afAddrType_t *dstAddr,
   1401                                                    zclLocationGetData_t *locData,
   1402                                                    uint8 disableDefaultRsp, uint8 seqNum )
   1403          {
   1404            uint8 buf[10]; // bitmap (1) + number responses (1) + IEEE Address (8)
   1405            uint8 *pBuf = buf;
   1406            uint8 len = 2; // bitmap + number responses
   1407          
   1408            *pBuf  = locData->absoluteOnly;
   1409            *pBuf |= locData->recalculate << 1;
   1410            *pBuf |= locData->brdcastIndicator << 2;
   1411            *pBuf |= locData->brdcastResponse << 3;
   1412            *pBuf |= locData->compactResponse << 4;
   1413            pBuf++;  // move past the bitmap field
   1414          
   1415            *pBuf++ = locData->numResponses;
   1416          
   1417            if ( locData->brdcastIndicator == 0 )
   1418            {
   1419              zcl_memcpy( pBuf, locData->targetAddr, 8 );
   1420              len += 8; // ieee addr
   1421            }
   1422          
   1423            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1424                                    COMMAND_LOCATION_GET_DATA, TRUE,
   1425                                    ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, len, buf );
   1426          }
   1427          
   1428          /*********************************************************************
   1429           * @fn      zclGeneral_SendLocationDevCfgResponse
   1430           *
   1431           * @brief   Call to send out a Device Configuration Response Command
   1432           *
   1433           * @param   srcEP - Sending application's endpoint
   1434           * @param   dstAddr - where you want the message to go
   1435           * @param   devCfg - device's location parameters that are requested
   1436           *
   1437           * @return  ZStatus_t
   1438           */
   1439          ZStatus_t zclGeneral_SendLocationDevCfgResponse( uint8 srcEP, afAddrType_t *dstAddr,
   1440                                                           zclLocationDevCfgRsp_t *devCfg,
   1441                                                           uint8 disableDefaultRsp, uint8 seqNum )
   1442          {
   1443            uint8 buf[10]; // 4 fields (2 octects each) + 2 fields (1 octect each)
   1444            uint8 len = 1; // Status
   1445          
   1446            buf[0] = devCfg->status;
   1447            if ( devCfg->status == ZCL_STATUS_SUCCESS )
   1448            {
   1449              buf[1] = LO_UINT16( devCfg->data.power );
   1450              buf[2] = HI_UINT16( devCfg->data.power );
   1451              buf[3] = LO_UINT16( devCfg->data.pathLossExponent );
   1452              buf[4] = HI_UINT16( devCfg->data.pathLossExponent );
   1453              buf[5] = LO_UINT16( devCfg->data.calcPeriod );
   1454              buf[6] = HI_UINT16( devCfg->data.calcPeriod );
   1455              buf[7] = devCfg->data.numMeasurements;
   1456              buf[8] = LO_UINT16( devCfg->data.reportPeriod );
   1457              buf[9] = HI_UINT16( devCfg->data.reportPeriod );
   1458              len += 9;
   1459            }
   1460          
   1461            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1462                                    COMMAND_LOCATION_DEV_CFG_RSP, TRUE,
   1463                                    ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, len, buf );
   1464          }
   1465          
   1466          /*********************************************************************
   1467           * @fn      zclGeneral_SendLocationData
   1468           *
   1469           * @brief   Call to send out location data
   1470           *
   1471           * @param   srcEP - Sending application's endpoint
   1472           * @param   dstAddr - where you want the message to go
   1473           * @param   status - indicates whether response to request was successful or not
   1474           * @param   locData - location information and channel parameters being sent
   1475           *
   1476           * @return  ZStatus_t
   1477           */
   1478          ZStatus_t zclGeneral_SendLocationData( uint8 srcEP, afAddrType_t *dstAddr, uint8 cmd,
   1479                                                 uint8 status, zclLocationData_t *locData,
   1480                                                 uint8 disableDefaultRsp, uint8 seqNum )
   1481          {
   1482            uint8 buf[16];
   1483            uint8 *pBuf = buf;
   1484            uint8 len = 0;
   1485          
   1486            if ( cmd == COMMAND_LOCATION_DATA_RSP )
   1487            {
   1488              // Only response command includes a status field
   1489              *pBuf++ = status;
   1490              len++;
   1491            }
   1492          
   1493            if ( cmd != COMMAND_LOCATION_DATA_RSP || status == ZCL_STATUS_SUCCESS )
   1494            {
   1495              // Notification or Response with successful status
   1496              *pBuf++ = locData->type;
   1497              *pBuf++ = LO_UINT16( locData->absLoc.coordinate1 );
   1498              *pBuf++ = HI_UINT16( locData->absLoc.coordinate1 );
   1499              *pBuf++ = LO_UINT16( locData->absLoc.coordinate2 );
   1500              *pBuf++ = HI_UINT16( locData->absLoc.coordinate2 );
   1501              len += 5;
   1502          
   1503              if ( locationType2D(locData->type) == 0 )
   1504              {
   1505                // 2D location doesn't have coordinate 3
   1506                *pBuf++ = LO_UINT16( locData->absLoc.coordinate3 );
   1507                *pBuf++ = HI_UINT16( locData->absLoc.coordinate3 );
   1508                len += 2;
   1509              }
   1510          
   1511              if ( cmd != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   1512              {
   1513                // Compact notification doesn't include these fields
   1514                *pBuf++ = LO_UINT16( locData->absLoc.power );
   1515                *pBuf++ = HI_UINT16( locData->absLoc.power );
   1516                *pBuf++ = LO_UINT16( locData->absLoc.pathLossExponent );
   1517                *pBuf++ = HI_UINT16( locData->absLoc.pathLossExponent );
   1518                len += 4;
   1519              }
   1520          
   1521              if ( locationTypeAbsolute(locData->type) == 0 )
   1522              {
   1523                // Absolute location doesn't include these fields
   1524                if ( cmd != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   1525                {
   1526                  // Compact notification doesn't include this field
   1527                  *pBuf++ = locData->calcLoc.locationMethod;
   1528                  len++;
   1529                }
   1530          
   1531                *pBuf++ = locData->calcLoc.qualityMeasure;
   1532                *pBuf++ = LO_UINT16( locData->calcLoc.locationAge );
   1533                *pBuf++ = HI_UINT16( locData->calcLoc.locationAge );
   1534                len += 3;
   1535              }
   1536            }
   1537          
   1538            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1539                                    cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
   1540                                    disableDefaultRsp, 0, seqNum, len, buf );
   1541          }
   1542          #endif // ZCL_LOCATION
   1543          
   1544          /*********************************************************************
   1545           * @fn      zclGeneral_FindCallbacks
   1546           *
   1547           * @brief   Find the callbacks for an endpoint
   1548           *
   1549           * @param   endpoint - endpoint to find the application callbacks for
   1550           *
   1551           * @return  pointer to the callbacks
   1552           */
   1553          static zclGeneral_AppCallbacks_t *zclGeneral_FindCallbacks( uint8 endpoint )
   1554          {
   1555            zclGenCBRec_t *pCBs;
   1556          
   1557            pCBs = zclGenCBs;
   1558            while ( pCBs )
   1559            {
   1560              if ( pCBs->endpoint == endpoint )
   1561                return ( pCBs->CBs );
   1562              pCBs = pCBs->next;
   1563            }
   1564            return ( (zclGeneral_AppCallbacks_t *)NULL );
   1565          }
   1566          
   1567          /*********************************************************************
   1568           * @fn      zclGeneral_HdlIncoming
   1569           *
   1570           * @brief   Callback from ZCL to process incoming Commands specific
   1571           *          to this cluster library or Profile commands for attributes
   1572           *          that aren't in the attribute list
   1573           *
   1574           *
   1575           * @param   pInMsg - pointer to the incoming message
   1576           *
   1577           * @return  ZStatus_t
   1578           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1579          static ZStatus_t zclGeneral_HdlIncoming( zclIncoming_t *pInMsg )
   \                     zclGeneral_HdlIncoming:
   1580          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1581            ZStatus_t stat = ZSuccess;
   1582          
   1583          #if defined ( INTER_PAN )
   1584            if ( StubAPS_InterPan( pInMsg->msg->srcAddr.panId, pInMsg->msg->srcAddr.endPoint ) )
   1585              return ( stat ); // Cluster not supported thru Inter-PAN
   1586          #endif
   1587            if ( zcl_ClusterCmd( pInMsg->hdr.fc.type ) )
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   5407         ANL     A,#0x7
   \   00000D   6401         XRL     A,#0x1
   \   00000F   7007         JNZ     ??zclGeneral_HdlIncoming_0
   1588            {
   1589              // Is this a manufacturer specific command?
   1590              if ( pInMsg->hdr.fc.manuSpecific == 0 )
   1591              {
   1592                stat = zclGeneral_HdlInSpecificCommands( pInMsg );
   \   000011                ; Setup parameters for call to function zclGeneral_HdlInSpecificCommands
   \   000011   12....       LCALL   `??zclGeneral_HdlInSpecificCommands::?relay`; Banked call to: zclGeneral_HdlInSpecificCommands
   \   000014   E9           MOV     A,R1
   \   000015   F9           MOV     R1,A
   \   000016   8002         SJMP    ??zclGeneral_HdlIncoming_1
   1593              }
   1594              else
   1595              {
   1596                // We don't support any manufacturer specific command.
   1597                stat = ZFailure;
   1598              }
   1599            }
   1600            else
   1601            {
   1602              // Handle all the normal (Read, Write...) commands -- should never get here
   1603              stat = ZFailure;
   \                     ??zclGeneral_HdlIncoming_0:
   \   000018   7901         MOV     R1,#0x1
   1604            }
   1605            return ( stat );
   \                     ??zclGeneral_HdlIncoming_1:
   \   00001A   D083         POP     DPH
   \   00001C   D082         POP     DPL
   \   00001E   02....       LJMP    ?BRET
   1606          }
   1607          
   1608          /*********************************************************************
   1609           * @fn      zclGeneral_HdlInSpecificCommands
   1610           *
   1611           * @brief   Callback from ZCL to process incoming Commands specific
   1612           *          to this cluster library
   1613          
   1614           * @param   pInMsg - pointer to the incoming message
   1615           *
   1616           * @return  ZStatus_t
   1617           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1618          static ZStatus_t zclGeneral_HdlInSpecificCommands( zclIncoming_t *pInMsg )
   \                     zclGeneral_HdlInSpecificCommands:
   1619          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   1620            ZStatus_t stat;
   1621            zclGeneral_AppCallbacks_t *pCBs;
   1622          
   1623            // make sure endpoint exists
   1624            pCBs = zclGeneral_FindCallbacks( pInMsg->msg->endPoint );
   \   000009   8E82         MOV     DPL,R6
   \   00000B   8F83         MOV     DPH,R7
   \   00000D   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   000010   FA           MOV     R2,A
   \   000011   E9           MOV     A,R1
   \   000012   FB           MOV     R3,A
   \   000013   EA           MOV     A,R2
   \   000014   2414         ADD     A,#0x14
   \   000016   F582         MOV     DPL,A
   \   000018   E4           CLR     A
   \   000019   3B           ADDC    A,R3
   \   00001A   F583         MOV     DPH,A
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   FC           MOV     R4,A
   \   00001E   90....       MOV     DPTR,#zclGenCBs
   \                     ??zclGeneral_HdlInSpecificCommands_0:
   \   000021   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   000024   49           ORL     A,R1
   \   000025   6056         JZ      ??zclGeneral_HdlInSpecificCommands_1
   \   000027   8882         MOV     DPL,R0
   \   000029   8983         MOV     DPH,R1
   \   00002B   A3           INC     DPTR
   \   00002C   A3           INC     DPTR
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   6C           XRL     A,R4
   \   00002F   8882         MOV     DPL,R0
   \   000031   8983         MOV     DPH,R1
   \   000033   70EC         JNZ     ??zclGeneral_HdlInSpecificCommands_0
   \   000035   A3           INC     DPTR
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   00003B   FC           MOV     R4,A
   \   00003C   E9           MOV     A,R1
   \   00003D   FD           MOV     R5,A
   1625            if ( pCBs == NULL )
   \   00003E   EC           MOV     A,R4
   \   00003F   4D           ORL     A,R5
   \   000040   603B         JZ      ??zclGeneral_HdlInSpecificCommands_1
   1626              return ( ZFailure );
   1627          
   1628            switch ( pInMsg->msg->clusterId )
   \   000042   8A82         MOV     DPL,R2
   \   000044   8B83         MOV     DPH,R3
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   F5..         MOV     ?V0,A
   \   00004D   A3           INC     DPTR
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   F5..         MOV     ?V1,A
   \   000051   78..         MOV     R0,#?V0
   \   000053   12....       LCALL   ?US_SWITCH_SPARSE
   \                     `?<Jumptable for zclGeneral_HdlInSpecificComman_0`:
   \   000056   0000         DW        0
   \   000058   0200         DW        2
   \   00005A   0000         DW        0
   \   00005C   ....         DW        ??zclGeneral_HdlInSpecificCommands_2
   \   00005E   0600         DW        6
   \   000060   ....         DW        ??zclGeneral_HdlInSpecificCommands_3
   \   000062   ....         DW        ??zclGeneral_HdlInSpecificCommands_1
   1629            {
   1630          #ifdef ZCL_BASIC
   1631              case ZCL_CLUSTER_ID_GEN_BASIC:
   1632                stat = zclGeneral_ProcessInBasic( pInMsg, pCBs );
   \                     ??zclGeneral_HdlInSpecificCommands_2:
   \   000064   8E82         MOV     DPL,R6
   \   000066   8F83         MOV     DPH,R7
   \   000068   A3           INC     DPTR
   \   000069   A3           INC     DPTR
   \   00006A   E0           MOVX    A,@DPTR
   \   00006B   5408         ANL     A,#0x8
   \   00006D   701E         JNZ     ??zclGeneral_HdlInSpecificCommands_4
   \   00006F   8E82         MOV     DPL,R6
   \   000071   8F83         MOV     DPH,R7
   \   000073   A3           INC     DPTR
   \   000074   A3           INC     DPTR
   \   000075   A3           INC     DPTR
   \   000076   A3           INC     DPTR
   \   000077   A3           INC     DPTR
   \   000078   A3           INC     DPTR
   \   000079   A3           INC     DPTR
   \   00007A   E0           MOVX    A,@DPTR
   \   00007B   6004         JZ      ??zclGeneral_HdlInSpecificCommands_5
   \                     ??zclGeneral_HdlInSpecificCommands_1:
   \   00007D   7901         MOV     R1,#0x1
   \   00007F   8050         SJMP    ??zclGeneral_HdlInSpecificCommands_6
   \                     ??zclGeneral_HdlInSpecificCommands_5:
   \   000081   8C82         MOV     DPL,R4
   \   000083   8D83         MOV     DPH,R5
   \   000085   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   000088   6003         JZ      ??zclGeneral_HdlInSpecificCommands_4
   \   00008A                ; Setup parameters for indirect call
   \   00008A   12....       LCALL   ?CALL_IND
   \                     ??zclGeneral_HdlInSpecificCommands_4:
   \   00008D   7900         MOV     R1,#0x0
   \   00008F   8040         SJMP    ??zclGeneral_HdlInSpecificCommands_6
   1633                break;
   1634          #endif // ZCL_BASIC
   1635          
   1636          #ifdef ZCL_IDENTIFY
   1637              case ZCL_CLUSTER_ID_GEN_IDENTIFY:
   1638                stat = zclGeneral_ProcessInIdentity( pInMsg, pCBs );
   1639                break;
   1640          #endif // ZCL_IDENTIFY
   1641          
   1642          #ifdef ZCL_GROUPS
   1643              case ZCL_CLUSTER_ID_GEN_GROUPS:
   1644                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1645                  stat = zclGeneral_ProcessInGroupsServer( pInMsg );
   1646                else
   1647                  stat = zclGeneral_ProcessInGroupsClient( pInMsg, pCBs );
   1648                break;
   1649          #endif // ZCL_GROUPS
   1650          
   1651          #ifdef ZCL_SCENES
   1652              case ZCL_CLUSTER_ID_GEN_SCENES:
   1653                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1654                  stat = zclGeneral_ProcessInScenesServer( pInMsg, pCBs );
   1655                else
   1656                  stat = zclGeneral_ProcessInScenesClient( pInMsg, pCBs );
   1657                break;
   1658          #endif // ZCL_SCENES
   1659          
   1660          #ifdef ZCL_ON_OFF
   1661              case ZCL_CLUSTER_ID_GEN_ON_OFF:
   1662                stat = zclGeneral_ProcessInOnOff( pInMsg, pCBs );
   \                     ??zclGeneral_HdlInSpecificCommands_3:
   \   000091   75..00       MOV     ?V0,#0x0
   \   000094   8E82         MOV     DPL,R6
   \   000096   8F83         MOV     DPH,R7
   \   000098   A3           INC     DPTR
   \   000099   A3           INC     DPTR
   \   00009A   E0           MOVX    A,@DPTR
   \   00009B   5408         ANL     A,#0x8
   \   00009D   7030         JNZ     ??zclGeneral_HdlInSpecificCommands_7
   \   00009F   8E82         MOV     DPL,R6
   \   0000A1   8F83         MOV     DPH,R7
   \   0000A3   A3           INC     DPTR
   \   0000A4   A3           INC     DPTR
   \   0000A5   A3           INC     DPTR
   \   0000A6   A3           INC     DPTR
   \   0000A7   A3           INC     DPTR
   \   0000A8   A3           INC     DPTR
   \   0000A9   A3           INC     DPTR
   \   0000AA   E0           MOVX    A,@DPTR
   \   0000AB   FA           MOV     R2,A
   \   0000AC   6006         JZ      ??zclGeneral_HdlInSpecificCommands_8
   \   0000AE   14           DEC     A
   \   0000AF   6003         JZ      ??zclGeneral_HdlInSpecificCommands_8
   \   0000B1   14           DEC     A
   \   0000B2   7018         JNZ     ??zclGeneral_HdlInSpecificCommands_9
   \                     ??zclGeneral_HdlInSpecificCommands_8:
   \   0000B4   8C82         MOV     DPL,R4
   \   0000B6   8D83         MOV     DPH,R5
   \   0000B8   A3           INC     DPTR
   \   0000B9   A3           INC     DPTR
   \   0000BA   A3           INC     DPTR
   \   0000BB   A3           INC     DPTR
   \   0000BC   A3           INC     DPTR
   \   0000BD   A3           INC     DPTR
   \   0000BE   A3           INC     DPTR
   \   0000BF   A3           INC     DPTR
   \   0000C0   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_1:
   \   0000C3   600A         JZ      ??zclGeneral_HdlInSpecificCommands_7
   \   0000C5                ; Setup parameters for indirect call
   \   0000C5   EA           MOV     A,R2
   \   0000C6   F9           MOV     R1,A
   \   0000C7   12....       LCALL   ?CALL_IND
   \   0000CA   8003         SJMP    ??zclGeneral_HdlInSpecificCommands_7
   \                     ??zclGeneral_HdlInSpecificCommands_9:
   \   0000CC   75..01       MOV     ?V0,#0x1
   \                     ??zclGeneral_HdlInSpecificCommands_7:
   \   0000CF   A9..         MOV     R1,?V0
   1663                break;
   1664          #endif // ZCL_ON_OFF
   1665          
   1666          #ifdef ZCL_LEVEL_CTRL
   1667              case ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL:
   1668                stat = zclGeneral_ProcessInLevelControl( pInMsg, pCBs );
   1669                break;
   1670          #endif // ZCL_LEVEL_CTRL
   1671          
   1672          #ifdef ZCL_ALARMS
   1673              case ZCL_CLUSTER_ID_GEN_ALARMS:
   1674                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1675                  stat = zclGeneral_ProcessInAlarmsServer( pInMsg, pCBs );
   1676                else
   1677                  stat = zclGeneral_ProcessInAlarmsClient( pInMsg, pCBs );
   1678                break;
   1679          #endif // ZCL_ALARMS
   1680          
   1681          #ifdef ZCL_LOCATION
   1682              case ZCL_CLUSTER_ID_GEN_LOCATION:
   1683                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1684                  stat = zclGeneral_ProcessInLocationServer( pInMsg, pCBs );
   1685                else
   1686                  stat = zclGeneral_ProcessInLocationClient( pInMsg, pCBs );
   1687                break;
   1688          #endif // ZCL_LOCATION
   1689          
   1690              case ZCL_CLUSTER_ID_GEN_POWER_CFG:
   1691              case ZCL_CLUSTER_ID_GEN_DEVICE_TEMP_CONFIG:
   1692              case ZCL_CLUSTER_ID_GEN_ON_OFF_SWITCH_CONFIG:
   1693              case ZCL_CLUSTER_ID_GEN_TIME:
   1694              default:
   1695                stat = ZFailure;
   1696                break;
   1697            }
   1698          
   1699            return ( stat );
   \                     ??zclGeneral_HdlInSpecificCommands_6:
   \   0000D1   7F02         MOV     R7,#0x2
   \   0000D3   02....       LJMP    ?BANKED_LEAVE_XDATA
   1700          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   E8           MOV     A,R0
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   8882         MOV     DPL,R0
   \   000007   8983         MOV     DPH,R1
   \   000009   E582         MOV     A,DPL
   \   00000B   4583         ORL     A,DPH
   \   00000D   22           RET

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGeneral_RegisterCmdCallbacks::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_RegisterCmdCallbacks

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGeneral_HdlIncoming::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_HdlIncoming

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGeneral_HdlInSpecificCommands::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_HdlInSpecificCommands
   1701          
   1702          #ifdef ZCL_BASIC
   1703          /*********************************************************************
   1704           * @fn      zclGeneral_ProcessInBasic
   1705           *
   1706           * @brief   Process in the received Basic Command.
   1707           *
   1708           * @param   pInMsg - pointer to the incoming message
   1709           *
   1710           * @return  ZStatus_t
   1711           */
   1712          static ZStatus_t zclGeneral_ProcessInBasic( zclIncoming_t *pInMsg,
   1713                                                      zclGeneral_AppCallbacks_t *pCBs )
   1714          {
   1715            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1716            {
   1717              if ( pInMsg->hdr.commandID > COMMAND_BASIC_RESET_FACT_DEFAULT )
   1718                return ( ZFailure );   // Error ignore the command
   1719          
   1720              if ( pCBs->pfnBasicReset )
   1721                pCBs->pfnBasicReset();
   1722            }
   1723            // no Client command
   1724          
   1725            return ( ZSuccess );
   1726          }
   1727          #endif // ZCL_BASIC
   1728          
   1729          #ifdef ZCL_IDENTIFY
   1730          /*********************************************************************
   1731           * @fn      zclGeneral_ProcessInIdentity
   1732           *
   1733           * @brief   Process in the received Identity Command.
   1734           *
   1735           * @param   pInMsg - pointer to the incoming message
   1736           *
   1737           * @return  ZStatus_t
   1738           */
   1739          static ZStatus_t zclGeneral_ProcessInIdentity( zclIncoming_t *pInMsg,
   1740                                                         zclGeneral_AppCallbacks_t *pCBs )
   1741          {
   1742            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1743            {
   1744              if ( pInMsg->hdr.commandID == COMMAND_IDENTIFY )
   1745              {
   1746                if ( pCBs->pfnIdentify )
   1747                {
   1748                  zclIdentify_t cmd;
   1749          
   1750                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   1751                  cmd.identifyTime = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
   1752          
   1753                  pCBs->pfnIdentify( &cmd );
   1754                }
   1755              }
   1756              else if ( pInMsg->hdr.commandID == COMMAND_IDENTIFY_QUERY )
   1757              {
   1758                uint16 identifyTime = 0;
   1759          
   1760                // Retrieve Identify Time
   1761                zcl_ReadAttrData( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   1762                                  ATTRID_IDENTIFY_TIME, (uint8 *)&identifyTime, NULL );
   1763          
   1764                // Is device identifying itself?
   1765                if ( identifyTime > 0 )
   1766                {
   1767                  zclGeneral_SendIdentifyQueryResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1768                                                        identifyTime, true, pInMsg->hdr.transSeqNum );
   1769          #ifdef ZCL_EZMODE
   1770                  zcl_EZModeAction( EZMODE_ACTION_IDENTIFY_QUERY, NULL );
   1771          #endif
   1772                  return ( ZCL_STATUS_CMD_HAS_RSP );
   1773                }
   1774              }
   1775          #ifdef ZCL_EZMODE
   1776              else if ( pInMsg->hdr.commandID == COMMAND_IDENTIFY_EZMODE_INVOKE )
   1777              {
   1778                if ( pCBs->pfnIdentifyEZModeInvoke )
   1779                {
   1780                  pCBs->pfnIdentifyEZModeInvoke( pInMsg->pData[0] );
   1781                }
   1782              }
   1783              else if ( pInMsg->hdr.commandID == COMMAND_IDENTIFY_UPDATE_COMMISSION_STATE )
   1784              {
   1785                if ( pCBs->pfnIdentifyUpdateCommState )
   1786                {
   1787                  zclIdentifyUpdateCommState_t cmd;
   1788          
   1789                  cmd.action = pInMsg->pData[0];
   1790                  cmd.commissionStateMask = pInMsg->pData[1];
   1791          
   1792                  pCBs->pfnIdentifyUpdateCommState( &cmd );
   1793                }
   1794              }
   1795          #endif
   1796          
   1797          #ifdef ZCL_LIGHT_LINK_ENHANCE
   1798              else if ( pInMsg->hdr.commandID == COMMAND_IDENTIFY_TRIGGER_EFFECT )
   1799              {
   1800                if ( pCBs->pfnIdentifyTriggerEffect )
   1801                {
   1802                  zclIdentifyTriggerEffect_t cmd;
   1803          
   1804                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   1805                  cmd.effectId = pInMsg->pData[0];
   1806                  cmd.effectVariant = pInMsg->pData[1];
   1807          
   1808                  pCBs->pfnIdentifyTriggerEffect( &cmd );
   1809                }
   1810              }
   1811          #endif //ZCL_LIGHT_LINK_ENHANCE
   1812              else
   1813              {
   1814                return ( ZFailure );   // Error ignore the command
   1815              }
   1816            }
   1817            else // Client Command
   1818            {
   1819              if ( pInMsg->hdr.commandID > COMMAND_IDENTIFY_QUERY_RSP )
   1820                return ( ZFailure );   // Error ignore the command
   1821          
   1822              if ( pCBs->pfnIdentifyQueryRsp )
   1823              {
   1824                zclIdentifyQueryRsp_t rsp;
   1825          
   1826                rsp.srcAddr = &(pInMsg->msg->srcAddr);
   1827                rsp.timeout = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
   1828          
   1829                pCBs->pfnIdentifyQueryRsp( &rsp );
   1830              }
   1831            }
   1832          
   1833            return ( ZSuccess );
   1834          }
   1835          #endif // ZCL_IDENTIFY
   1836          
   1837          #ifdef ZCL_GROUPS
   1838          
   1839          /*********************************************************************
   1840           * @fn      zclGeneral_AddGroup
   1841           *
   1842           * @brief   Add a Group.
   1843           *
   1844           * @param   endPoint - application endpoint
   1845           * @param   group - group to be added
   1846           * @param   pData - pointer to the group info
   1847           *
   1848           * @return  ZStatus_t
   1849           */
   1850          static ZStatus_t zclGeneral_AddGroup( uint8 endPoint, aps_Group_t *group, uint8 *pData )
   1851          {
   1852            uint8 nameLen;
   1853            uint8 nameSupport = FALSE;
   1854          
   1855            pData += 2;   // Move past group ID
   1856            nameLen = *pData++;
   1857          
   1858            // Retrieve Name Support attribute
   1859            zcl_ReadAttrData( endPoint, ZCL_CLUSTER_ID_GEN_GROUPS,
   1860                              ATTRID_GROUP_NAME_SUPPORT, &nameSupport, NULL );
   1861          
   1862            if ( nameSupport )
   1863            {
   1864              if ( nameLen > (APS_GROUP_NAME_LEN-1) )
   1865                 nameLen = (APS_GROUP_NAME_LEN-1);
   1866              group->name[0] = nameLen;
   1867              zcl_memcpy( &(group->name[1]), pData, nameLen );
   1868            }
   1869          
   1870            return ( aps_AddGroup( endPoint, group ) );
   1871          }
   1872          
   1873          /*********************************************************************
   1874           * @fn      zclGeneral_ProcessInGroupsServer
   1875           *
   1876           * @brief   Process in the received Groups Command.
   1877           *
   1878           * @param   pInMsg - pointer to the incoming message
   1879           *
   1880           * @return  ZStatus_t
   1881           */
   1882          static ZStatus_t zclGeneral_ProcessInGroupsServer( zclIncoming_t *pInMsg )
   1883          {
   1884            aps_Group_t group;
   1885            aps_Group_t *pGroup;
   1886            uint8 *pData;
   1887            uint8 status;
   1888            uint8 grpCnt;
   1889            uint8 grpRspCnt = 0;
   1890            uint16 *grpList;
   1891            uint16 identifyTime = 0;
   1892            uint8 i;
   1893            ZStatus_t stat = ZSuccess;
   1894          
   1895            zcl_memset( (uint8*)&group, 0, sizeof( aps_Group_t ) );
   1896          
   1897            pData = pInMsg->pData;
   1898            group.ID = BUILD_UINT16( pData[0], pData[1] );
   1899            switch ( pInMsg->hdr.commandID )
   1900            {
   1901              case COMMAND_GROUP_ADD:
   1902                status = zclGeneral_AddGroup( pInMsg->msg->endPoint, &group, pData );
   1903                if ( status != ZSuccess )
   1904                {
   1905                  if ( status == ZApsDuplicateEntry )
   1906                  {
   1907                    status = ZCL_STATUS_DUPLICATE_EXISTS;
   1908                  }
   1909                  else
   1910                  {
   1911                    status = ZCL_STATUS_INSUFFICIENT_SPACE;
   1912                  }
   1913                }
   1914          #if defined( ZCL_LIGHT_LINK_ENHANCE ) //ZLL allows response to unicast only
   1915                if ( UNICAST_MSG( pInMsg->msg ) )
   1916          #endif
   1917                {
   1918                  zclGeneral_SendGroupAddResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1919                                                   status, group.ID, true, pInMsg->hdr.transSeqNum );
   1920                  stat = ZCL_STATUS_CMD_HAS_RSP;
   1921                }
   1922                break;
   1923          
   1924              case COMMAND_GROUP_VIEW:
   1925          #if defined( ZCL_LIGHT_LINK_ENHANCE ) //ZLL allows response to unicast only
   1926                if ( UNICAST_MSG( pInMsg->msg ) )
   1927          #endif
   1928                {
   1929                  pGroup = aps_FindGroup( pInMsg->msg->endPoint, group.ID );
   1930                  if ( pGroup )
   1931                  {
   1932                    status = ZCL_STATUS_SUCCESS;
   1933                  }
   1934                  else
   1935                  {
   1936                    // Group not found
   1937                    status = ZCL_STATUS_NOT_FOUND;
   1938                    pGroup = &group;
   1939                  }
   1940                  zclGeneral_SendGroupViewResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1941                                                    status, pGroup, true, pInMsg->hdr.transSeqNum );
   1942                  stat = ZCL_STATUS_CMD_HAS_RSP;
   1943                }
   1944                break;
   1945          
   1946              case COMMAND_GROUP_GET_MEMBERSHIP:
   1947          #if defined( ZCL_LIGHT_LINK_ENHANCE ) //ZLL allows response to unicast only
   1948                if ( UNICAST_MSG( pInMsg->msg ) )
   1949          #endif
   1950                {
   1951                  grpCnt = *pData++;
   1952          
   1953                  // Allocate space for the group list
   1954                  grpList = zcl_mem_alloc( sizeof( uint16 ) * APS_MAX_GROUPS );
   1955                  if ( grpList != NULL )
   1956                  {
   1957                    if ( grpCnt == 0 )
   1958                    {
   1959                      // Find out all the groups of which the endpoint is a member.
   1960                      grpRspCnt = aps_FindAllGroupsForEndpoint( pInMsg->msg->endPoint, grpList );
   1961                    }
   1962                    else
   1963                    {
   1964                      // Find out the groups (in the list) of which the endpoint is a member.
   1965                      for ( i = 0; i < grpCnt; i++ )
   1966                      {
   1967                        group.ID = BUILD_UINT16( pData[0], pData[1] );
   1968                        pData += 2;
   1969          
   1970                        if ( aps_FindGroup( pInMsg->msg->endPoint, group.ID ) )
   1971                          grpList[grpRspCnt++] = group.ID;
   1972                      }
   1973                    }
   1974          
   1975                    if ( grpCnt == 0 ||  grpRspCnt != 0 )
   1976                    {
   1977                      zclGeneral_SendGroupGetMembershipResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1978                                                                 aps_GroupsRemaingCapacity(), grpRspCnt,
   1979                                                                 grpList, true, pInMsg->hdr.transSeqNum );
   1980                    }
   1981          
   1982                    zcl_mem_free( grpList );
   1983                  }
   1984                  else
   1985                  {
   1986                    // Couldn't allocate space for the group list -- send a Default Response command back.
   1987                    zclDefaultRspCmd_t defaultRspCmd;
   1988          
   1989                    defaultRspCmd.commandID = pInMsg->hdr.commandID;
   1990                    defaultRspCmd.statusCode = ZCL_STATUS_INSUFFICIENT_SPACE;
   1991                    zcl_SendDefaultRspCmd( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   1992                                           pInMsg->msg->clusterId, &defaultRspCmd,
   1993                                           ZCL_FRAME_SERVER_CLIENT_DIR, true, 0, pInMsg->hdr.transSeqNum );
   1994                  }
   1995          
   1996                  stat = ZCL_STATUS_CMD_HAS_RSP;
   1997                }
   1998                break;
   1999          
   2000              case COMMAND_GROUP_REMOVE:
   2001          #if defined ( ZCL_SCENES )
   2002                zclGeneral_RemoveAllScenes( pInMsg->msg->endPoint, group.ID );
   2003          #endif
   2004                if ( aps_RemoveGroup( pInMsg->msg->endPoint, group.ID ) )
   2005                {
   2006                  status = ZCL_STATUS_SUCCESS;
   2007                }
   2008                else
   2009                {
   2010                  status = ZCL_STATUS_NOT_FOUND;
   2011                }
   2012          
   2013          #if defined( ZCL_LIGHT_LINK_ENHANCE ) //ZLL allows response to unicast only
   2014                if ( UNICAST_MSG( pInMsg->msg ) )
   2015          #endif
   2016                {
   2017                  zclGeneral_SendGroupRemoveResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2018                                                      status, group.ID, true, pInMsg->hdr.transSeqNum );
   2019                  stat = ZCL_STATUS_CMD_HAS_RSP;
   2020                }
   2021                break;
   2022          
   2023              case COMMAND_GROUP_REMOVE_ALL:
   2024                {
   2025                  uint8 numGroups;
   2026                  uint16 groupList[APS_MAX_GROUPS];
   2027          
   2028                  if ( numGroups = aps_FindAllGroupsForEndpoint( pInMsg->msg->endPoint, groupList ) )
   2029                  {
   2030                    for ( i = 0; i < numGroups; i++ )
   2031                    {
   2032          #if defined ( ZCL_SCENES )
   2033                      zclGeneral_RemoveAllScenes( pInMsg->msg->endPoint, groupList[i] );
   2034          #endif
   2035                    }
   2036          
   2037                    aps_RemoveAllGroup( pInMsg->msg->endPoint );
   2038                  }
   2039                }
   2040                break;
   2041          
   2042              case COMMAND_GROUP_ADD_IF_IDENTIFYING:
   2043                // Retrieve Identify Time
   2044                zcl_ReadAttrData( pInMsg->msg->endPoint, ZCL_CLUSTER_ID_GEN_IDENTIFY,
   2045                                  ATTRID_IDENTIFY_TIME, (uint8 *)&identifyTime, NULL );
   2046          
   2047                // Is device identifying itself?
   2048                if ( identifyTime > 0 )
   2049                {
   2050                  zclGeneral_AddGroup( pInMsg->msg->endPoint, &group, pData );
   2051                }
   2052                break;
   2053          
   2054              default:
   2055                stat = ZFailure;
   2056                break;
   2057            }
   2058          
   2059            return ( stat );
   2060          }
   2061          
   2062          /*********************************************************************
   2063           * @fn      zclGeneral_ProcessInGroupsClient
   2064           *
   2065           * @brief   Process in the received Groups Command.
   2066           *
   2067           * @param   pInMsg - pointer to the incoming message
   2068           *
   2069           * @return  ZStatus_t
   2070           */
   2071          static ZStatus_t zclGeneral_ProcessInGroupsClient( zclIncoming_t *pInMsg,
   2072                                                             zclGeneral_AppCallbacks_t *pCBs )
   2073          {
   2074            aps_Group_t group;
   2075            uint8 *pData = pInMsg->pData;
   2076            uint8 grpCnt;
   2077            uint8 nameLen;
   2078            zclGroupRsp_t rsp;
   2079            uint8 i;
   2080            ZStatus_t stat = ZSuccess;
   2081          
   2082            zcl_memset( (uint8*)&group, 0, sizeof( aps_Group_t ) );
   2083            zcl_memset( (uint8*)&rsp, 0, sizeof( zclGroupRsp_t ) );
   2084          
   2085            switch ( pInMsg->hdr.commandID )
   2086            {
   2087              case COMMAND_GROUP_ADD_RSP:
   2088              case COMMAND_GROUP_VIEW_RSP:
   2089              case COMMAND_GROUP_REMOVE_RSP:
   2090                rsp.status = *pData++;
   2091                group.ID = BUILD_UINT16( pData[0], pData[1] );
   2092          
   2093                if ( rsp.status == ZCL_STATUS_SUCCESS && pInMsg->hdr.commandID == COMMAND_GROUP_VIEW_RSP )
   2094                {
   2095                  pData += 2;   // Move past ID
   2096                  nameLen = *pData++;
   2097                  if ( nameLen > (APS_GROUP_NAME_LEN-1) )
   2098                    nameLen = (APS_GROUP_NAME_LEN-1);
   2099                  group.name[0] = nameLen;
   2100                  zcl_memcpy( &(group.name[1]), pData, nameLen );
   2101                  rsp.grpName = group.name;
   2102                }
   2103          
   2104                if ( pCBs->pfnGroupRsp )
   2105                {
   2106                  rsp.srcAddr = &(pInMsg->msg->srcAddr);
   2107                  rsp.cmdID = pInMsg->hdr.commandID;
   2108                  rsp.grpCnt = 1;
   2109                  rsp.grpList = &group.ID;
   2110                  rsp.capacity = 0;
   2111          
   2112                  pCBs->pfnGroupRsp( &rsp );
   2113                }
   2114                break;
   2115          
   2116              case COMMAND_GROUP_GET_MEMBERSHIP_RSP:
   2117                {
   2118                  uint16 *grpList = NULL;
   2119                  rsp.capacity = *pData++;
   2120                  grpCnt = *pData++;
   2121          
   2122                  if ( grpCnt > 0 )
   2123                  {
   2124                    // Allocate space for the group list
   2125                    grpList = zcl_mem_alloc( sizeof( uint16 ) * grpCnt );
   2126                    if ( grpList != NULL )
   2127                    {
   2128                      rsp.grpCnt = grpCnt;
   2129                      for ( i = 0; i < grpCnt; i++ )
   2130                      {
   2131                        grpList[i] = BUILD_UINT16( pData[0], pData[1] );
   2132                        pData += 2;
   2133                      }
   2134                    }
   2135                  }
   2136          
   2137                  if ( pCBs->pfnGroupRsp )
   2138                  {
   2139                    rsp.srcAddr = &(pInMsg->msg->srcAddr);
   2140                    rsp.cmdID = pInMsg->hdr.commandID;
   2141                    rsp.grpList = grpList;
   2142          
   2143                    pCBs->pfnGroupRsp( &rsp );
   2144                  }
   2145          
   2146                  if ( grpList != NULL )
   2147                  {
   2148                    zcl_mem_free( grpList );
   2149                  }
   2150                }
   2151                break;
   2152          
   2153              default:
   2154                stat = ZFailure;
   2155                break;
   2156            }
   2157          
   2158            return ( stat );
   2159          }
   2160          #endif // ZCL_GROUPS
   2161          
   2162          #if defined( ZCL_SCENES )
   2163          #if !defined ( ZCL_STANDALONE )
   2164          /*********************************************************************
   2165           * @fn      zclGeneral_AddScene
   2166           *
   2167           * @brief   Add a scene for an endpoint
   2168           *
   2169           * @param   endpoint -
   2170           * @param   scene - new scene item
   2171           *
   2172           * @return  ZStatus_t
   2173           */
   2174          ZStatus_t zclGeneral_AddScene( uint8 endpoint, zclGeneral_Scene_t *scene )
   2175          {
   2176            zclGenSceneItem_t *pNewItem;
   2177            zclGenSceneItem_t *pLoop;
   2178          
   2179            // Fill in the new profile list
   2180            pNewItem = zcl_mem_alloc( sizeof( zclGenSceneItem_t ) );
   2181            if ( pNewItem == NULL )
   2182              return ( ZMemError );
   2183          
   2184            // Fill in the plugin record.
   2185            pNewItem->next = (zclGenSceneItem_t *)NULL;
   2186            pNewItem->endpoint = endpoint;
   2187            zcl_memcpy( (uint8*)&(pNewItem->scene), (uint8*)scene, sizeof ( zclGeneral_Scene_t ));
   2188          
   2189            // Find spot in list
   2190            if (  zclGenSceneTable == NULL )
   2191            {
   2192              zclGenSceneTable = pNewItem;
   2193            }
   2194            else
   2195            {
   2196              // Look for end of list
   2197              pLoop = zclGenSceneTable;
   2198              while ( pLoop->next != NULL )
   2199                pLoop = pLoop->next;
   2200          
   2201              // Put new item at end of list
   2202              pLoop->next = pNewItem;
   2203            }
   2204          
   2205            // Update NV
   2206            zclGeneral_ScenesWriteNV();
   2207          
   2208            return ( ZSuccess );
   2209          }
   2210          #endif // ZCL_STANDALONE
   2211          
   2212          #if !defined ( ZCL_STANDALONE )
   2213          /*********************************************************************
   2214           * @fn      zclGeneral_FindScene
   2215           *
   2216           * @brief   Find a scene with endpoint and sceneID
   2217           *
   2218           * @param   endpoint -
   2219           * @param   groupID - what group the scene belongs to
   2220           * @param   sceneID - ID to look for scene
   2221           *
   2222           * @return  a pointer to the scene information, NULL if not found
   2223           */
   2224          zclGeneral_Scene_t *zclGeneral_FindScene( uint8 endpoint, uint16 groupID, uint8 sceneID )
   2225          {
   2226            zclGenSceneItem_t *pLoop;
   2227          
   2228            // Look for end of list
   2229            pLoop = zclGenSceneTable;
   2230            while ( pLoop )
   2231            {
   2232              if ( (pLoop->endpoint == endpoint || endpoint == 0xFF)
   2233                  && pLoop->scene.groupID == groupID && pLoop->scene.ID == sceneID )
   2234              {
   2235                return ( &(pLoop->scene) );
   2236              }
   2237              pLoop = pLoop->next;
   2238            }
   2239          
   2240            return ( (zclGeneral_Scene_t *)NULL );
   2241          }
   2242          #endif // ZCL_STANDALONE
   2243          
   2244          #if !defined ( ZCL_STANDALONE )
   2245          /*********************************************************************
   2246           * @fn      zclGeneral_FindAllScenesForGroup
   2247           *
   2248           * @brief   Find all the scenes with groupID
   2249           *
   2250           * @param   endpoint - endpoint to look for
   2251           * @param   sceneList - List to hold scene IDs (should hold APS_MAX_SCENES entries)
   2252           *
   2253           * @return  number of scenes copied to sceneList
   2254           */
   2255          uint8 zclGeneral_FindAllScenesForGroup( uint8 endpoint, uint16 groupID, uint8 *sceneList )
   2256          {
   2257            zclGenSceneItem_t *pLoop;
   2258            uint8 cnt = 0;
   2259          
   2260            // Look for end of list
   2261            pLoop = zclGenSceneTable;
   2262            while ( pLoop )
   2263            {
   2264              if ( pLoop->endpoint == endpoint && pLoop->scene.groupID == groupID )
   2265                sceneList[cnt++] = pLoop->scene.ID;
   2266              pLoop = pLoop->next;
   2267            }
   2268            return ( cnt );
   2269          }
   2270          #endif // ZCL_STANDALONE
   2271          
   2272          #if !defined ( ZCL_STANDALONE )
   2273          /*********************************************************************
   2274           * @fn      zclGeneral_RemoveScene
   2275           *
   2276           * @brief   Remove a scene with endpoint and sceneID
   2277           *
   2278           * @param   endpoint -
   2279           * @param   groupID - what group the scene belongs to
   2280           * @param   sceneID - ID to look for scene
   2281           *
   2282           * @return  TRUE if removed, FALSE if not found
   2283           */
   2284          uint8 zclGeneral_RemoveScene( uint8 endpoint, uint16 groupID, uint8 sceneID )
   2285          {
   2286            zclGenSceneItem_t *pLoop;
   2287            zclGenSceneItem_t *pPrev;
   2288          
   2289            // Look for end of list
   2290            pLoop = zclGenSceneTable;
   2291            pPrev = NULL;
   2292            while ( pLoop )
   2293            {
   2294              if ( pLoop->endpoint == endpoint
   2295                  && pLoop->scene.groupID == groupID && pLoop->scene.ID == sceneID )
   2296              {
   2297                if ( pPrev == NULL )
   2298                  zclGenSceneTable = pLoop->next;
   2299                else
   2300                  pPrev->next = pLoop->next;
   2301          
   2302                // Free the memory
   2303                zcl_mem_free( pLoop );
   2304          
   2305                // Update NV
   2306                zclGeneral_ScenesWriteNV();
   2307          
   2308                return ( TRUE );
   2309              }
   2310              pPrev = pLoop;
   2311              pLoop = pLoop->next;
   2312            }
   2313          
   2314            return ( FALSE );
   2315          }
   2316          #endif // ZCL_STANDALONE
   2317          
   2318          #if !defined ( ZCL_STANDALONE )
   2319          /*********************************************************************
   2320           * @fn      zclGeneral_RemoveAllScenes
   2321           *
   2322           * @brief   Remove all scenes with endpoint and group Id
   2323           *
   2324           * @param   endpoint -
   2325           * @param   groupID - ID to look for group
   2326           *
   2327           * @return  none
   2328           */
   2329          void zclGeneral_RemoveAllScenes( uint8 endpoint, uint16 groupID )
   2330          {
   2331            zclGenSceneItem_t *pLoop;
   2332            zclGenSceneItem_t *pPrev;
   2333            zclGenSceneItem_t *pNext;
   2334          
   2335            // Look for end of list
   2336            pLoop = zclGenSceneTable;
   2337            pPrev = NULL;
   2338            while ( pLoop )
   2339            {
   2340              if ( pLoop->endpoint == endpoint && pLoop->scene.groupID == groupID )
   2341              {
   2342                if ( pPrev == NULL )
   2343                  zclGenSceneTable = pLoop->next;
   2344                else
   2345                  pPrev->next = pLoop->next;
   2346                pNext = pLoop->next;
   2347          
   2348                // Free the memory
   2349                zcl_mem_free( pLoop );
   2350                pLoop = pNext;
   2351              }
   2352              else
   2353              {
   2354                pPrev = pLoop;
   2355                pLoop = pLoop->next;
   2356              }
   2357            }
   2358          
   2359            // Update NV
   2360            zclGeneral_ScenesWriteNV();
   2361          }
   2362          #endif // ZCL_STANDALONE
   2363          
   2364          #if !defined ( ZCL_STANDALONE )
   2365          /*********************************************************************
   2366           * @fn      zclGeneral_CountScenes
   2367           *
   2368           * @brief   Count the number of scenes for an endpoint
   2369           *
   2370           * @param   endpoint -
   2371           *
   2372           * @return  number of scenes assigned to an endpoint
   2373           */
   2374          uint8 zclGeneral_CountScenes( uint8 endpoint )
   2375          {
   2376            zclGenSceneItem_t *pLoop;
   2377            uint8 cnt = 0;
   2378          
   2379            // Look for end of list
   2380            pLoop = zclGenSceneTable;
   2381            while ( pLoop )
   2382            {
   2383              if ( pLoop->endpoint == endpoint  )
   2384                cnt++;
   2385              pLoop = pLoop->next;
   2386            }
   2387            return ( cnt );
   2388          }
   2389          #endif
   2390          
   2391          #if !defined ( ZCL_STANDALONE )
   2392          /*********************************************************************
   2393           * @fn      zclGeneral_CountAllScenes
   2394           *
   2395           * @brief   Count the total number of scenes
   2396           *
   2397           * @param   none
   2398           *
   2399           * @return  number of scenes
   2400           */
   2401          uint8 zclGeneral_CountAllScenes( void )
   2402          {
   2403            zclGenSceneItem_t *pLoop;
   2404            uint8 cnt = 0;
   2405          
   2406            // Look for end of list
   2407            pLoop = zclGenSceneTable;
   2408            while ( pLoop )
   2409            {
   2410              cnt++;
   2411              pLoop = pLoop->next;
   2412            }
   2413            return ( cnt );
   2414          }
   2415          #endif // ZCL_STANDALONE
   2416          
   2417          /*********************************************************************
   2418           * @fn      zclGeneral_ReadSceneCountCB
   2419           *
   2420           * @brief   Read the number of scenes currently in the device's
   2421           *          scene table (i.e., the Scene Count attribute).
   2422           *
   2423           *          Note: This function gets called only when the pointer
   2424           *                'dataPtr' to the Scene Count attribute value is
   2425           *                NULL in the attribute database registered with
   2426           *                the ZCL.
   2427           *
   2428           * @param   clusterId - cluster that attribute belongs to
   2429           * @param   attrId - attribute to be read or written
   2430           * @param   oper - ZCL_OPER_LEN, ZCL_OPER_READ, or ZCL_OPER_WRITE
   2431           * @param   pValue - pointer to attribute value
   2432           * @param   pLen - pointer to length of attribute value read
   2433           *
   2434           * @return  status
   2435           */
   2436          ZStatus_t zclGeneral_ReadSceneCountCB( uint16 clusterId, uint16 attrId,
   2437                                                 uint8 oper, uint8 *pValue, uint16 *pLen )
   2438          {
   2439            ZStatus_t status = ZCL_STATUS_SUCCESS;
   2440          
   2441            // This callback function should only be called for the Scene Count attribute
   2442            switch ( oper )
   2443            {
   2444              case ZCL_OPER_LEN:
   2445                *pLen = 1; // uint8
   2446                break;
   2447          
   2448              case ZCL_OPER_READ:
   2449                *pValue = zclGeneral_CountAllScenes();
   2450          
   2451                if ( pLen != NULL )
   2452                {
   2453                  *pLen = 1;
   2454                }
   2455                break;
   2456          
   2457              case ZCL_OPER_WRITE:
   2458                // Fall through
   2459          
   2460              default:
   2461                status = ZCL_STATUS_SOFTWARE_FAILURE; // should never get here!
   2462                break;
   2463            }
   2464          
   2465            return ( status );
   2466          }
   2467          
   2468          /*********************************************************************
   2469           * @fn      zclGeneral_ProcessInScenesServer
   2470           *
   2471           * @brief   Process in the received Scenes Command.
   2472           *
   2473           * @param   pInMsg - pointer to the incoming message
   2474           *
   2475           * @return  ZStatus_t
   2476           */
   2477          static ZStatus_t zclGeneral_ProcessInScenesServer( zclIncoming_t *pInMsg,
   2478                                                             zclGeneral_AppCallbacks_t *pCBs )
   2479          {
   2480            zclGeneral_Scene_t scene;
   2481            zclGeneral_Scene_t *pScene;
   2482            uint8 *pData = pInMsg->pData;
   2483            uint8 nameLen;
   2484            uint8 status;
   2485            uint8 sceneCnt = 0;
   2486            uint8 *sceneList = NULL;
   2487            uint8 sendRsp = TRUE;
   2488            uint8 nameSupport = FALSE;
   2489            ZStatus_t stat = ZSuccess;
   2490          
   2491            zcl_memset( (uint8*)&scene, 0, sizeof( zclGeneral_Scene_t ) );
   2492          
   2493            scene.groupID = BUILD_UINT16( pData[0], pData[1] );
   2494            pData += 2;   // Move past group ID
   2495            scene.ID = *pData++;
   2496          
   2497            switch ( pInMsg->hdr.commandID )
   2498            {
   2499              case COMMAND_SCENE_ADD:
   2500          #ifdef ZCL_LIGHT_LINK_ENHANCE
   2501              case COMMAND_SCENE_ENHANCED_ADD:
   2502          #endif // ZCL_LIGHT_LINK_ENHANCE
   2503                // Parse the rest of the incoming message
   2504                scene.transTime = BUILD_UINT16( pData[0], pData[1] );
   2505                pData += 2;
   2506          
   2507                if ( pInMsg->hdr.commandID == COMMAND_SCENE_ENHANCED_ADD )
   2508                {
   2509                  // Received transition time is in 1/10 second
   2510                  scene.transTime100ms = scene.transTime % 10;
   2511                  scene.transTime /= 10;
   2512                }
   2513          
   2514                nameLen= *pData++; // Name length
   2515          
   2516                // Retrieve Name Support attribute
   2517                zcl_ReadAttrData( pInMsg->msg->endPoint, ZCL_CLUSTER_ID_GEN_SCENES,
   2518                                  ATTRID_SCENES_NAME_SUPPORT, &nameSupport, NULL );
   2519          
   2520                if ( nameSupport )
   2521                {
   2522                  if ( nameLen > (ZCL_GEN_SCENE_NAME_LEN-1) )
   2523                    nameLen = (ZCL_GEN_SCENE_NAME_LEN-1);
   2524                  scene.name[0] = nameLen;
   2525                  zcl_memcpy( &(scene.name[1]), pData, nameLen );
   2526                }
   2527          
   2528                pData += nameLen; // move past name, use original length
   2529          
   2530                scene.extLen = pInMsg->pDataLen - ( (uint16)( pData - pInMsg->pData ) );
   2531                if ( scene.extLen > 0 )
   2532                {
   2533                  // Copy the extention field(s)
   2534                  if ( scene.extLen > ZCL_GEN_SCENE_EXT_LEN )
   2535                  {
   2536                    scene.extLen = ZCL_GEN_SCENE_EXT_LEN;
   2537                  }
   2538                  zcl_memcpy( scene.extField, pData, scene.extLen );
   2539                }
   2540          
   2541                if ( scene.groupID == 0x0000 ||
   2542                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   2543                {
   2544                  // Either the Scene doesn't belong to a Group (Group ID = 0x0000) or it
   2545                  // does and the corresponding Group exits
   2546                  pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   2547                  if ( pScene || ( zclGeneral_CountAllScenes() < ZCL_GEN_MAX_SCENES ) )
   2548                  {
   2549                    status = ZCL_STATUS_SUCCESS;
   2550                    if ( pScene != NULL )
   2551                    {
   2552                      // The Scene already exists so update it
   2553                      pScene->transTime = scene.transTime;
   2554                      zcl_memcpy( pScene->name, scene.name, ZCL_GEN_SCENE_NAME_LEN );
   2555          
   2556                      // Use the new extention field(s)
   2557                      zcl_memcpy( pScene->extField, scene.extField, scene.extLen );
   2558                      pScene->extLen = scene.extLen;
   2559          
   2560                      // Save Scenes
   2561                      zclGeneral_ScenesSave();
   2562                    }
   2563                    else
   2564                    {
   2565                      // The Scene doesn't exist so add it
   2566                      zclGeneral_AddScene( pInMsg->msg->endPoint, &scene );
   2567                    }
   2568                  }
   2569                  else
   2570                  {
   2571                    status = ZCL_STATUS_INSUFFICIENT_SPACE; // The Scene Table is full
   2572                  }
   2573                }
   2574                else
   2575                {
   2576                  status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
   2577                }
   2578          
   2579                if ( UNICAST_MSG( pInMsg->msg ) )
   2580                {
   2581                  if ( pInMsg->hdr.commandID == COMMAND_SCENE_ADD )
   2582                  {
   2583                    zclGeneral_SendSceneAddResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2584                                                    status, scene.groupID, scene.ID,
   2585                                                    true, pInMsg->hdr.transSeqNum );
   2586                  }
   2587          #ifdef ZCL_LIGHT_LINK_ENHANCE
   2588                  else // COMMAND_SCENE_ENHANCED_ADD
   2589                  {
   2590                    zclGeneral_SendSceneEnhancedAddResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2591                                                            status, scene.groupID, scene.ID,
   2592                                                            true, pInMsg->hdr.transSeqNum );
   2593                  }
   2594          #endif // ZCL_LIGHT_LINK_ENHANCE
   2595                }
   2596                stat = ZCL_STATUS_CMD_HAS_RSP;
   2597          
   2598                break;
   2599          
   2600              case COMMAND_SCENE_VIEW:
   2601          #ifdef ZCL_LIGHT_LINK_ENHANCE
   2602              case COMMAND_SCENE_ENHANCED_VIEW:
   2603          #endif // ZCL_LIGHT_LINK_ENHANCE
   2604                pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   2605                if ( pScene != NULL )
   2606                {
   2607                  status = ZCL_STATUS_SUCCESS;
   2608                }
   2609                else
   2610                {
   2611                  // Scene not found
   2612                  if ( scene.groupID != 0x0000 &&
   2613                       aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) == NULL )
   2614                  {
   2615                    status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
   2616                  }
   2617                  else
   2618                  {
   2619                    status = ZCL_STATUS_NOT_FOUND;
   2620                  }
   2621                  pScene = &scene;
   2622                }
   2623          
   2624                if ( UNICAST_MSG( pInMsg->msg ) )
   2625                {
   2626                  if ( pInMsg->hdr.commandID == COMMAND_SCENE_VIEW )
   2627                  {
   2628                    zclGeneral_SendSceneViewResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2629                                                     status, pScene, true, pInMsg->hdr.transSeqNum );
   2630                  }
   2631          #ifdef ZCL_LIGHT_LINK_ENHANCE
   2632                  else
   2633                  {
   2634                    zclGeneral_SendSceneEnhancedViewResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2635                                                             status, pScene, true, pInMsg->hdr.transSeqNum );
   2636                  }
   2637          #endif // ZCL_LIGHT_LINK_ENHANCE
   2638                }
   2639                stat = ZCL_STATUS_CMD_HAS_RSP;
   2640                break;
   2641          
   2642              case COMMAND_SCENE_REMOVE:
   2643                if ( zclGeneral_RemoveScene( pInMsg->msg->endPoint, scene.groupID, scene.ID ) )
   2644                {
   2645                  status = ZCL_STATUS_SUCCESS;
   2646                }
   2647                else
   2648                {
   2649                  // Scene not found
   2650                  if ( aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) == NULL )
   2651                  {
   2652                    // The Group is not in the Group Table
   2653                    status = ZCL_STATUS_INVALID_FIELD;
   2654                  }
   2655                  else
   2656                  {
   2657                    status = ZCL_STATUS_NOT_FOUND;
   2658                  }
   2659                }
   2660          
   2661                if ( UNICAST_MSG( pInMsg->msg ) )
   2662                {
   2663                  // Addressed to this device (not to a group) - send a response back
   2664                  zclGeneral_SendSceneRemoveResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2665                                                      status, scene.groupID,
   2666                                                      scene.ID, true, pInMsg->hdr.transSeqNum );
   2667                }
   2668                stat = ZCL_STATUS_CMD_HAS_RSP;
   2669                break;
   2670          
   2671              case COMMAND_SCENE_REMOVE_ALL:
   2672                if ( scene.groupID == 0x0000 ||
   2673                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   2674                {
   2675                  zclGeneral_RemoveAllScenes( pInMsg->msg->endPoint, scene.groupID );
   2676                  status = ZCL_STATUS_SUCCESS;
   2677                }
   2678                else
   2679                {
   2680                  status = ZCL_STATUS_INVALID_FIELD;
   2681                }
   2682          
   2683                if ( UNICAST_MSG( pInMsg->msg ) )
   2684                {
   2685                  // Addressed to this device (not to a group) - send a response back
   2686                  zclGeneral_SendSceneRemoveAllResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2687                                                         status, scene.groupID, true, pInMsg->hdr.transSeqNum );
   2688                }
   2689                stat = ZCL_STATUS_CMD_HAS_RSP;
   2690                break;
   2691          
   2692              case COMMAND_SCENE_STORE:
   2693                if ( scene.groupID == 0x0000 ||
   2694                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   2695                {
   2696                  // Either the Scene doesn't belong to a Group (Group ID = 0x0000) or it
   2697                  // does and the corresponding Group exits
   2698                  pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   2699                  if ( pScene || ( zclGeneral_CountAllScenes() < ZCL_GEN_MAX_SCENES ) )
   2700                  {
   2701                    uint8 sceneChanged = FALSE;
   2702          
   2703                    status = ZCL_STATUS_SUCCESS;
   2704                    if ( pScene == NULL )
   2705                    {
   2706                      // Haven't been added yet
   2707                      pScene = &scene;
   2708                    }
   2709          
   2710                    if ( pCBs->pfnSceneStoreReq )
   2711                    {
   2712                      zclSceneReq_t req;
   2713          
   2714                      req.srcAddr = &(pInMsg->msg->srcAddr);
   2715                      req.scene = pScene;
   2716          
   2717                      // Get the latest Scene info
   2718                      if ( pCBs->pfnSceneStoreReq( &req ) )
   2719                      {
   2720                        sceneChanged = TRUE;
   2721                      }
   2722                    }
   2723          
   2724                    if ( pScene == &scene )
   2725                    {
   2726                      // The Scene doesn't exist so add it
   2727                      zclGeneral_AddScene( pInMsg->msg->endPoint, &scene );
   2728                    }
   2729                    else if ( sceneChanged )
   2730                    {
   2731                      // The Scene already exists so update only NV
   2732                      zclGeneral_ScenesSave();
   2733                    }
   2734                  }
   2735                  else
   2736                  {
   2737                    status = ZCL_STATUS_INSUFFICIENT_SPACE; // The Scene Table is full
   2738                  }
   2739                }
   2740                else
   2741                {
   2742                  status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
   2743                }
   2744          
   2745                if ( UNICAST_MSG( pInMsg->msg ) )
   2746                {
   2747                  // Addressed to this device (not to a group) - send a response back
   2748                  zclGeneral_SendSceneStoreResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2749                                                     status, scene.groupID, scene.ID,
   2750                                                     true, pInMsg->hdr.transSeqNum );
   2751                }
   2752                stat = ZCL_STATUS_CMD_HAS_RSP;
   2753                break;
   2754          
   2755              case COMMAND_SCENE_RECALL:
   2756                pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   2757                if ( pScene && pCBs->pfnSceneRecallReq )
   2758                {
   2759                  zclSceneReq_t req;
   2760          
   2761                  req.srcAddr = &(pInMsg->msg->srcAddr);
   2762                  req.scene = pScene;
   2763          
   2764                  pCBs->pfnSceneRecallReq( &req );
   2765                }
   2766                // No response
   2767                break;
   2768          
   2769              case COMMAND_SCENE_GET_MEMBERSHIP:
   2770                // Find all the Scenes corresponding to the Group ID
   2771                if ( scene.groupID == 0x0000 ||
   2772                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   2773                {
   2774                  // Allocate space for the scene list
   2775                  sceneList = zcl_mem_alloc( ZCL_GEN_MAX_SCENES );
   2776                  if ( sceneList != NULL )
   2777                  {
   2778                    sceneCnt = zclGeneral_FindAllScenesForGroup( pInMsg->msg->endPoint,
   2779                                                                 scene.groupID, sceneList );
   2780                    status = ZCL_STATUS_SUCCESS;
   2781                    if ( ! UNICAST_MSG( pInMsg->msg ) )
   2782                    {
   2783                      // Addressed to the Group - ONLY send a response if an entry within the
   2784                      // Scene Table corresponds to the Group ID
   2785                      if ( sceneCnt == 0 )
   2786                      {
   2787                        sendRsp = FALSE;
   2788                      }
   2789                    }
   2790                  }
   2791                  else
   2792                  {
   2793                    // Couldn't allocate space for the scene list!
   2794                    status = ZCL_STATUS_INSUFFICIENT_SPACE;
   2795                  }
   2796                }
   2797                else
   2798                {
   2799                  // The Group is not in the Group Table - send a response back
   2800                  status = ZCL_STATUS_INVALID_FIELD;
   2801                }
   2802          
   2803          #ifdef ZCL_LIGHT_LINK_ENHANCE //ZLL allows response to unicast only
   2804                if ( sendRsp && UNICAST_MSG( pInMsg->msg ) )
   2805          #else
   2806                if ( sendRsp )
   2807          #endif //ZCL_LIGHT_LINK_ENHANCE
   2808                {
   2809                  zclGeneral_SendSceneGetMembershipResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2810                                              status, zclGeneral_ScenesRemaingCapacity(), sceneCnt, sceneList,
   2811                                              scene.groupID, true, pInMsg->hdr.transSeqNum );
   2812                }
   2813          
   2814                if ( sceneList != NULL )
   2815                  zcl_mem_free( sceneList );
   2816          
   2817                stat = ZCL_STATUS_CMD_HAS_RSP;
   2818                break;
   2819          
   2820          #ifdef ZCL_LIGHT_LINK_ENHANCE
   2821              case COMMAND_SCENE_COPY:
   2822                {
   2823                  uint8 mode;
   2824                  uint16 groupIDFrom, groupIDTo;
   2825                  uint8 sceneIDFrom, sceneIDTo;
   2826          
   2827                  pData = pInMsg->pData; // different payload format
   2828          
   2829                  mode = *pData++;
   2830                  groupIDFrom = BUILD_UINT16( pData[0], pData[1] ); // from group ID
   2831                  pData += 2;
   2832                  sceneIDFrom = *pData++; // from scene ID
   2833                  groupIDTo = BUILD_UINT16( pData[0], pData[1] ); // to group ID
   2834                  pData += 2;
   2835                  if ( (mode & SCENE_COPY_MODE_ALL_BIT) == 0 )
   2836                  {
   2837                    sceneIDTo = *pData++; // to scene ID
   2838                  }
   2839          
   2840                  // Make sure the groups exist
   2841                  if ( ( aps_FindGroup( pInMsg->msg->endPoint, groupIDFrom ) != NULL ) &&
   2842                       ( aps_FindGroup( pInMsg->msg->endPoint, groupIDTo ) != NULL ) )
   2843                  {
   2844                    // Allocate space for the scene list
   2845                    sceneList = zcl_mem_alloc( (mode & SCENE_COPY_MODE_ALL_BIT) ? ZCL_GEN_MAX_SCENES : 1 );
   2846                    if ( sceneList == NULL )
   2847                    {
   2848                      status = ZCL_STATUS_INSUFFICIENT_SPACE; // Couldn't allocate space for the scene list!
   2849                    }
   2850                    else
   2851                    {
   2852                      status = ZCL_STATUS_SUCCESS;
   2853                      if ( mode & SCENE_COPY_MODE_ALL_BIT ) // Copy all scenes
   2854                      {
   2855                        sceneCnt = zclGeneral_FindAllScenesForGroup( pInMsg->msg->endPoint,
   2856                                                                     groupIDFrom, sceneList );
   2857                      }
   2858                      else // Copy single scene
   2859                      {
   2860                        // Make sure the scene exists
   2861                        pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, groupIDFrom, sceneIDFrom );
   2862                        if ( pScene != NULL )
   2863                        {
   2864                          sceneList[0] = sceneIDFrom;
   2865                          sceneCnt = 1;
   2866                        }
   2867                        else
   2868                        {
   2869                          status = ZCL_STATUS_INVALID_FIELD; // Scene not found
   2870                        }
   2871                      }
   2872                    }
   2873          
   2874                    if ( status == ZCL_STATUS_SUCCESS )
   2875                    {
   2876                      uint8 numScenesToAdd = 0;
   2877                      uint8 i;
   2878                      for ( i = 0; i < sceneCnt; i++ )
   2879                      {
   2880                        if ( zclGeneral_FindScene( pInMsg->msg->endPoint, groupIDTo, sceneList[i] ) == NULL )
   2881                        {
   2882                          numScenesToAdd++;
   2883                        }
   2884                      }
   2885                      if ( zclGeneral_ScenesRemaingCapacity() >= numScenesToAdd )
   2886                      {
   2887                        // Copy the scenes
   2888                        for ( i = 0; i < sceneCnt; i++ )
   2889                        {
   2890                          // Ignore scene ID from and scene ID to fields
   2891                          pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, groupIDFrom, sceneList[i] );
   2892                          if ( pScene != NULL )
   2893                          {
   2894                            zclGeneral_Scene_t *pToScene;
   2895                            scene = *pScene;
   2896                            scene.groupID = groupIDTo;
   2897                            scene.ID = ( (mode & SCENE_COPY_MODE_ALL_BIT) ? sceneList[i] : sceneIDTo );
   2898          
   2899                            pToScene = zclGeneral_FindScene( pInMsg->msg->endPoint, groupIDTo, scene.ID );
   2900                            if( pToScene != NULL )
   2901                            {
   2902                              zclGeneral_RemoveScene( pInMsg->msg->endPoint, groupIDTo, scene.ID );
   2903                            }
   2904                            // Add the scene
   2905                            zclGeneral_AddScene( pInMsg->msg->endPoint, &scene );
   2906                          }
   2907                        }
   2908                      }
   2909                      else
   2910                      {
   2911                        status = ZCL_STATUS_INSUFFICIENT_SPACE; // The Scene Table is full
   2912                      }
   2913                    }
   2914                  }
   2915                  else
   2916                  {
   2917                    status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
   2918                  }
   2919          
   2920                  if ( UNICAST_MSG( pInMsg->msg ) )
   2921                  {
   2922                    if ( pScene == NULL )
   2923                    {
   2924                      pScene = &scene;
   2925                    }
   2926                    // Addressed to this device (not to a group) - send a response back
   2927                    zclGeneral_SendSceneCopyResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2928                                                      status, pScene->groupID, pScene->ID,
   2929                                                      true, pInMsg->hdr.transSeqNum );
   2930                  }
   2931          
   2932                  if ( sceneList != NULL )
   2933                  {
   2934                    zcl_mem_free( sceneList );
   2935                  }
   2936                }
   2937          
   2938                stat = ZCL_STATUS_CMD_HAS_RSP;
   2939                break;
   2940          #endif // ZCL_LIGHT_LINK_ENHANCE
   2941          
   2942              default:
   2943                stat = ZFailure;
   2944              break;
   2945            }
   2946          
   2947            return ( stat );
   2948          }
   2949          
   2950          /*********************************************************************
   2951           * @fn      zclGeneral_ProcessInScenesClient
   2952           *
   2953           * @brief   Process in the received Scenes Command.
   2954           *
   2955           * @param   pInMsg - pointer to the incoming message
   2956           *
   2957           * @return  ZStatus_t
   2958           */
   2959          static ZStatus_t zclGeneral_ProcessInScenesClient( zclIncoming_t *pInMsg,
   2960                                                             zclGeneral_AppCallbacks_t *pCBs )
   2961          {
   2962            zclGeneral_Scene_t scene;
   2963            uint8 *pData = pInMsg->pData;
   2964            uint8 nameLen;
   2965            zclSceneRsp_t rsp;
   2966            uint8 i;
   2967            ZStatus_t stat = ZSuccess;
   2968          
   2969            zcl_memset( (uint8*)&scene, 0, sizeof( zclGeneral_Scene_t ) );
   2970            zcl_memset( (uint8*)&rsp, 0, sizeof( zclSceneRsp_t ) );
   2971          
   2972            // Get the status field first
   2973            rsp.status = *pData++;
   2974          
   2975            if ( pInMsg->hdr.commandID == COMMAND_SCENE_GET_MEMBERSHIP_RSP )
   2976            {
   2977              rsp.capacity = *pData++;
   2978            }
   2979          
   2980            scene.groupID = BUILD_UINT16( pData[0], pData[1] );
   2981            pData += 2;   // Move past group ID
   2982          
   2983            switch ( pInMsg->hdr.commandID )
   2984            {
   2985              case COMMAND_SCENE_VIEW_RSP:
   2986                // Parse the rest of the incoming message
   2987                scene.ID = *pData++; // Not applicable to Remove All Response command
   2988                scene.transTime = BUILD_UINT16( pData[0], pData[1] );
   2989                pData += 2;
   2990                nameLen = *pData++; // Name length
   2991                if ( nameLen > (ZCL_GEN_SCENE_NAME_LEN-1) )
   2992                  nameLen = (ZCL_GEN_SCENE_NAME_LEN-1);
   2993          
   2994                scene.name[0] = nameLen;
   2995                zcl_memcpy( &(scene.name[1]), pData, nameLen );
   2996          
   2997                pData += nameLen; // move past name, use original length
   2998          
   2999                //*** Do something with the extension field(s)
   3000          
   3001                // Fall through to callback - break is left off intentionally
   3002          
   3003              case COMMAND_SCENE_ADD_RSP:
   3004              case COMMAND_SCENE_REMOVE_RSP:
   3005              case COMMAND_SCENE_REMOVE_ALL_RSP:
   3006              case COMMAND_SCENE_STORE_RSP:
   3007                if ( pCBs->pfnSceneRsp )
   3008                {
   3009                  if ( pInMsg->hdr.commandID != COMMAND_SCENE_REMOVE_ALL_RSP )
   3010                  {
   3011                    scene.ID = *pData++;
   3012                  }
   3013                  rsp.srcAddr = &(pInMsg->msg->srcAddr);
   3014                  rsp.cmdID = pInMsg->hdr.commandID;
   3015                  rsp.scene = &scene;
   3016          
   3017                  pCBs->pfnSceneRsp( &rsp );
   3018                }
   3019                break;
   3020          
   3021              case COMMAND_SCENE_GET_MEMBERSHIP_RSP:
   3022                {
   3023                  uint8 *sceneList = NULL;
   3024          
   3025                  if ( rsp.status == ZCL_STATUS_SUCCESS )
   3026                  {
   3027                    uint8 sceneCnt = *pData++;
   3028          
   3029                    if ( sceneCnt > 0 )
   3030                    {
   3031                      // Allocate space for the scene list
   3032                      sceneList = zcl_mem_alloc( sceneCnt );
   3033                      if ( sceneList != NULL )
   3034                      {
   3035                        rsp.sceneCnt = sceneCnt;
   3036                        for ( i = 0; i < sceneCnt; i++ )
   3037                          sceneList[i] = *pData++;
   3038                      }
   3039                    }
   3040                  }
   3041          
   3042                  if ( pCBs->pfnSceneRsp )
   3043                  {
   3044                    rsp.srcAddr = &(pInMsg->msg->srcAddr);
   3045                    rsp.cmdID = pInMsg->hdr.commandID;
   3046                    rsp.sceneList = sceneList;
   3047                    rsp.scene = &scene;
   3048          
   3049                    pCBs->pfnSceneRsp( &rsp);
   3050                  }
   3051          
   3052                  if ( sceneList != NULL )
   3053                  {
   3054                    zcl_mem_free( sceneList );
   3055                  }
   3056                }
   3057                break;
   3058          
   3059              default:
   3060                stat = ZFailure;
   3061                break;
   3062            }
   3063          
   3064            return ( stat );
   3065          }
   3066          #endif // ZCL_SCENES
   3067          
   3068          #ifdef ZCL_ON_OFF
   3069          /*********************************************************************
   3070           * @fn      zclGeneral_ProcessInCmdOnOff
   3071           *
   3072           * @brief   Process in the received On/Off Command.
   3073           *
   3074           * @param   pInMsg - pointer to the incoming message
   3075           *
   3076           * @return  ZStatus_t
   3077           */
   3078          static ZStatus_t zclGeneral_ProcessInOnOff( zclIncoming_t *pInMsg,
   3079                                                      zclGeneral_AppCallbacks_t *pCBs )
   3080          {
   3081            ZStatus_t stat = ZSuccess;
   3082          
   3083            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   3084            {
   3085              switch ( pInMsg->hdr.commandID )
   3086              {
   3087                case COMMAND_OFF:
   3088                case COMMAND_ON:
   3089                case COMMAND_TOGGLE:
   3090                  if ( pCBs->pfnOnOff )
   3091                  {
   3092                    pCBs->pfnOnOff( pInMsg->hdr.commandID );
   3093                  }
   3094                  break;
   3095          
   3096          #ifdef ZCL_LIGHT_LINK_ENHANCE
   3097                case COMMAND_OFF_WITH_EFFECT:
   3098                  if ( pCBs->pfnOnOff_OffWithEffect )
   3099                  {
   3100                    zclOffWithEffect_t cmd;
   3101          
   3102                    cmd.srcAddr = &(pInMsg->msg->srcAddr);
   3103                    cmd.effectId = pInMsg->pData[0];
   3104                    cmd.effectVariant = pInMsg->pData[1];
   3105          
   3106                    pCBs->pfnOnOff_OffWithEffect( &cmd );
   3107                  }
   3108                  break;
   3109          
   3110                case COMMAND_ON_WITH_RECALL_GLOBAL_SCENE:
   3111                  if ( pCBs->pfnOnOff_OnWithRecallGlobalScene )
   3112                  {
   3113                    pCBs->pfnOnOff_OnWithRecallGlobalScene();
   3114                  }
   3115                  break;
   3116          
   3117                case COMMAND_ON_WITH_TIMED_OFF:
   3118                  if ( pCBs->pfnOnOff_OnWithTimedOff )
   3119                  {
   3120                    zclOnWithTimedOff_t cmd;
   3121          
   3122                    cmd.onOffCtrl.byte = pInMsg->pData[0];
   3123                    cmd.onTime = BUILD_UINT16( pInMsg->pData[1], pInMsg->pData[2] );
   3124                    cmd.offWaitTime = BUILD_UINT16( pInMsg->pData[3], pInMsg->pData[4] );
   3125                    pCBs->pfnOnOff_OnWithTimedOff( &cmd );
   3126                  }
   3127                  break;
   3128          #endif // ZCL_LIGHT_LINK_ENHANCE
   3129          
   3130                default:
   3131                  stat = ZFailure;
   3132                  break;
   3133              }
   3134            }
   3135            // no Client command
   3136          
   3137            return ( stat );
   3138          }
   3139          #endif // ZCL_ON_OFF
   3140          
   3141          #ifdef ZCL_LEVEL_CTRL
   3142          /*********************************************************************
   3143           * @fn      zclGeneral_ProcessInLevelControl
   3144           *
   3145           * @brief   Process in the received Level Control Command.
   3146           *
   3147           * @param   pInMsg - pointer to the incoming message
   3148           *
   3149           * @return  ZStatus_t
   3150           */
   3151          static ZStatus_t zclGeneral_ProcessInLevelControl( zclIncoming_t *pInMsg,
   3152                                                             zclGeneral_AppCallbacks_t *pCBs )
   3153          {
   3154            uint8 withOnOff = FALSE;
   3155            ZStatus_t stat = ZSuccess;
   3156          
   3157            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   3158            {
   3159              switch ( pInMsg->hdr.commandID )
   3160              {
   3161                case COMMAND_LEVEL_MOVE_TO_LEVEL_WITH_ON_OFF:
   3162                  withOnOff = TRUE;
   3163                  // fall through
   3164                case COMMAND_LEVEL_MOVE_TO_LEVEL:
   3165                  if ( pCBs->pfnLevelControlMoveToLevel )
   3166                  {
   3167                    zclLCMoveToLevel_t cmd;
   3168          
   3169                    cmd.level = pInMsg->pData[0];
   3170          
   3171                    if ( ( cmd.level >= ATTR_LEVEL_MIN_LEVEL ) &&
   3172                         ( cmd.level <= ATTR_LEVEL_MAX_LEVEL ) )
   3173                    {
   3174                      cmd.transitionTime = BUILD_UINT16( pInMsg->pData[1], pInMsg->pData[2] );
   3175                      cmd.withOnOff = withOnOff;
   3176          
   3177                      pCBs->pfnLevelControlMoveToLevel( &cmd );
   3178                    }
   3179                    else
   3180                    {
   3181                      // level range requested is invalid
   3182                      stat = ZCL_STATUS_INVALID_VALUE;
   3183                    }
   3184                  }
   3185                  break;
   3186          
   3187                case COMMAND_LEVEL_MOVE_WITH_ON_OFF:
   3188                  withOnOff = TRUE;
   3189                  // fall through
   3190                case COMMAND_LEVEL_MOVE:
   3191                  if ( pCBs->pfnLevelControlMove )
   3192                  {
   3193                    zclLCMove_t cmd;
   3194          
   3195                    cmd.moveMode = pInMsg->pData[0];
   3196                    cmd.rate = pInMsg->pData[1];
   3197                    cmd.withOnOff = withOnOff;
   3198          
   3199                    pCBs->pfnLevelControlMove( &cmd );
   3200                  }
   3201                  break;
   3202          
   3203                case COMMAND_LEVEL_STEP_WITH_ON_OFF:
   3204                  withOnOff = TRUE;
   3205                  // fall through
   3206                case COMMAND_LEVEL_STEP:
   3207                  if ( pCBs->pfnLevelControlStep )
   3208                  {
   3209                    zclLCStep_t cmd;
   3210          
   3211                    cmd.stepMode = pInMsg->pData[0];
   3212                    cmd.amount =  pInMsg->pData[1];
   3213                    cmd.transitionTime = BUILD_UINT16( pInMsg->pData[2], pInMsg->pData[3] );
   3214                    cmd.withOnOff = withOnOff;
   3215          
   3216                    pCBs->pfnLevelControlStep( &cmd );
   3217                  }
   3218                  break;
   3219          
   3220                case COMMAND_LEVEL_STOP:
   3221                case COMMAND_LEVEL_STOP_WITH_ON_OFF:
   3222                  // Both Stop commands are identical
   3223                  if ( pCBs->pfnLevelControlStop )
   3224                  {
   3225                    pCBs->pfnLevelControlStop();
   3226                  }
   3227                  break;
   3228          
   3229                default:
   3230                  stat = ZFailure;
   3231                  break;
   3232              }
   3233            }
   3234            // no Client command
   3235          
   3236            return ( stat );
   3237          }
   3238          #endif // ZCL_LEVEL_CTRL
   3239          
   3240          #ifdef ZCL_ALARMS
   3241          /*********************************************************************
   3242           * @fn      zclGeneral_AddAlarm
   3243           *
   3244           * @brief   Add an alarm for a cluster
   3245           *
   3246           * @param   endpoint -
   3247           * @param   alarm - new alarm item
   3248           *
   3249           * @return  ZStatus_t
   3250           */
   3251          ZStatus_t zclGeneral_AddAlarm( uint8 endpoint, zclGeneral_Alarm_t *alarm )
   3252          {
   3253            zclGenAlarmItem_t *pNewItem;
   3254            zclGenAlarmItem_t *pLoop;
   3255          
   3256            // Fill in the new profile list
   3257            pNewItem = zcl_mem_alloc( sizeof( zclGenAlarmItem_t ) );
   3258            if ( pNewItem == NULL )
   3259              return ( ZMemError );
   3260          
   3261            // Fill in the plugin record.
   3262            pNewItem->next = (zclGenAlarmItem_t *)NULL;
   3263            pNewItem->endpoint =  endpoint;
   3264            zcl_memcpy( (uint8*)(&pNewItem->alarm), (uint8*)alarm, sizeof ( zclGeneral_Alarm_t ) );
   3265          
   3266            // Find spot in list
   3267            if (  zclGenAlarmTable == NULL )
   3268            {
   3269              zclGenAlarmTable = pNewItem;
   3270            }
   3271            else
   3272            {
   3273              // Look for end of list
   3274              pLoop = zclGenAlarmTable;
   3275              while ( pLoop->next != NULL )
   3276                pLoop = pLoop->next;
   3277          
   3278              // Put new item at end of list
   3279              pLoop->next = pNewItem;
   3280            }
   3281          
   3282            return ( ZSuccess );
   3283          }
   3284          
   3285          /*********************************************************************
   3286           * @fn      zclGeneral_FindAlarm
   3287           *
   3288           * @brief   Find an alarm with alarmCode and clusterID
   3289           *
   3290           * @param   endpoint -
   3291           * @param   groupID - what group the scene belongs to
   3292           * @param   sceneID - ID to look for scene
   3293           *
   3294           * @return  a pointer to the alarm information, NULL if not found
   3295           */
   3296          zclGeneral_Alarm_t *zclGeneral_FindAlarm( uint8 endpoint, uint8 alarmCode, uint16 clusterID )
   3297          {
   3298            zclGenAlarmItem_t *pLoop;
   3299          
   3300            // Look for the alarm
   3301            pLoop = zclGenAlarmTable;
   3302            while ( pLoop )
   3303            {
   3304              if ( pLoop->endpoint == endpoint &&
   3305                   pLoop->alarm.code == alarmCode && pLoop->alarm.clusterID == clusterID )
   3306              {
   3307                return ( &(pLoop->alarm) );
   3308              }
   3309              pLoop = pLoop->next;
   3310            }
   3311          
   3312            return ( (zclGeneral_Alarm_t *)NULL );
   3313          }
   3314          
   3315          /*********************************************************************
   3316           * @fn      zclGeneral_FindEarliestAlarm
   3317           *
   3318           * @brief   Find an alarm with the earliest timestamp
   3319           *
   3320           * @param   endpoint -
   3321           *
   3322           * @return  a pointer to the alarm information, NULL if not found
   3323           */
   3324          zclGeneral_Alarm_t *zclGeneral_FindEarliestAlarm( uint8 endpoint )
   3325          {
   3326            zclGenAlarmItem_t *pLoop;
   3327            zclGenAlarmItem_t earliestAlarm;
   3328            zclGenAlarmItem_t *pEarliestAlarm = &earliestAlarm;
   3329          
   3330            pEarliestAlarm->alarm.timeStamp = 0xFFFFFFFF;
   3331          
   3332            // Look for alarm with earliest time
   3333            pLoop = zclGenAlarmTable;
   3334            while ( pLoop )
   3335            {
   3336              if ( pLoop->endpoint == endpoint &&
   3337                   pLoop->alarm.timeStamp < pEarliestAlarm->alarm.timeStamp )
   3338              {
   3339                pEarliestAlarm = pLoop;
   3340              }
   3341              pLoop = pLoop->next;
   3342            }
   3343          
   3344            if ( pEarliestAlarm->alarm.timeStamp != 0xFFFFFFFF )
   3345              return ( &(pEarliestAlarm->alarm) );
   3346          
   3347            // No alarm
   3348            return ( (zclGeneral_Alarm_t *)NULL );
   3349          }
   3350          
   3351          /*********************************************************************
   3352           * @fn      zclGeneral_ResetAlarm
   3353           *
   3354           * @brief   Remove an alarm with alarmCode and clusterID
   3355           *
   3356           * @param   endpoint -
   3357           * @param   alarmCode -
   3358           * @param   clusterID -
   3359           *
   3360           * @return  TRUE if removed, FALSE if not found
   3361           */
   3362          void zclGeneral_ResetAlarm( uint8 endpoint, uint8 alarmCode, uint16 clusterID )
   3363          {
   3364            zclGenAlarmItem_t *pLoop;
   3365            zclGenAlarmItem_t *pPrev;
   3366          
   3367            // Look for end of list
   3368            pLoop = zclGenAlarmTable;
   3369            pPrev = NULL;
   3370            while ( pLoop )
   3371            {
   3372              if ( pLoop->endpoint == endpoint &&
   3373                   pLoop->alarm.code == alarmCode && pLoop->alarm.clusterID == clusterID )
   3374              {
   3375                if ( pPrev == NULL )
   3376                  zclGenAlarmTable = pLoop->next;
   3377                else
   3378                  pPrev->next = pLoop->next;
   3379          
   3380                // Free the memory
   3381                zcl_mem_free( pLoop );
   3382          
   3383                // Notify the Application so that if the alarm condition still active then
   3384                // a new notification will be generated, and a new alarm record will be
   3385                // added to the alarm log
   3386                // zclGeneral_NotifyReset( alarmCode, clusterID ); // callback function?
   3387                return;
   3388              }
   3389              pPrev = pLoop;
   3390              pLoop = pLoop->next;
   3391            }
   3392          }
   3393          
   3394          /*********************************************************************
   3395           * @fn      zclGeneral_ResetAllAlarms
   3396           *
   3397           * @brief   Remove all alarms with endpoint
   3398           *
   3399           * @param   endpoint -
   3400           * @param   notifyApp -
   3401           *
   3402           * @return  none
   3403           */
   3404          void zclGeneral_ResetAllAlarms( uint8 endpoint, uint8 notifyApp )
   3405          {
   3406            zclGenAlarmItem_t *pLoop;
   3407            zclGenAlarmItem_t *pPrev;
   3408            zclGenAlarmItem_t *pNext;
   3409          
   3410            // Look for end of list
   3411            pLoop = zclGenAlarmTable;
   3412            pPrev = NULL;
   3413            while ( pLoop )
   3414            {
   3415              if (  pLoop->endpoint == endpoint )
   3416              {
   3417                if ( pPrev == NULL )
   3418                  zclGenAlarmTable = pLoop->next;
   3419                else
   3420                  pPrev->next = pLoop->next;
   3421          
   3422                pNext = pLoop->next;
   3423          
   3424                // Free the memory
   3425                zcl_mem_free( pLoop );
   3426          
   3427                pLoop = pNext;
   3428              }
   3429              else
   3430              {
   3431                pPrev = pLoop;
   3432                pLoop = pLoop->next;
   3433              }
   3434            }
   3435          
   3436            if ( notifyApp )
   3437            {
   3438              // Notify the Application so that if any alarm conditions still active then
   3439              // a new notification will be generated, and a new alarm record will be
   3440              // added to the alarm log
   3441              // zclGeneral_NotifyResetAll(); // callback function?
   3442            }
   3443          }
   3444          
   3445          /*********************************************************************
   3446           * @fn      zclGeneral_ProcessInAlarmsServer
   3447           *
   3448           * @brief   Process in the received Alarms Command.
   3449           *
   3450           * @param   pInMsg - pointer to the incoming message
   3451           *
   3452           * @return  ZStatus_t
   3453           */
   3454          static ZStatus_t zclGeneral_ProcessInAlarmsServer( zclIncoming_t *pInMsg,
   3455                                                             zclGeneral_AppCallbacks_t *pCBs )
   3456          {
   3457            zclAlarm_t alarm;
   3458            zclGeneral_Alarm_t *pAlarm;
   3459            uint8 *pData = pInMsg->pData;
   3460            ZStatus_t stat = ZSuccess;
   3461          
   3462            switch ( pInMsg->hdr.commandID )
   3463            {
   3464              case COMMAND_ALARMS_RESET:
   3465                if ( pCBs->pfnAlarm )
   3466                {
   3467                  alarm.cmdID = pInMsg->hdr.commandID;
   3468                  alarm.alarmCode = pData[0];
   3469                  alarm.clusterID = BUILD_UINT16( pData[1], pData[2] );
   3470          
   3471                  pCBs->pfnAlarm( pInMsg->hdr.fc.direction, &alarm );
   3472                }
   3473                else
   3474                {
   3475                  stat = ZCL_STATUS_FAILURE;
   3476                }
   3477                break;
   3478          
   3479              case COMMAND_ALARMS_RESET_ALL:
   3480                if ( pCBs->pfnAlarm )
   3481                {
   3482                  alarm.cmdID = pInMsg->hdr.commandID;
   3483          
   3484                  pCBs->pfnAlarm( pInMsg->hdr.fc.direction, &alarm );
   3485                }
   3486                else
   3487                {
   3488                  stat = ZCL_STATUS_FAILURE;
   3489                }
   3490                break;
   3491          
   3492              case COMMAND_ALARMS_GET:
   3493                if ( pCBs->pfnAlarm )
   3494                {
   3495                  alarm.srcAddr = &(pInMsg->msg->srcAddr);
   3496                  alarm.cmdID = pInMsg->hdr.commandID;
   3497          
   3498                  pCBs->pfnAlarm( pInMsg->hdr.fc.direction, &alarm );
   3499          
   3500                  pAlarm = zclGeneral_FindEarliestAlarm( pInMsg->msg->endPoint );
   3501                  if ( pAlarm )
   3502                  {
   3503                    // Send a response back
   3504                    zclGeneral_SendAlarmGetResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   3505                                                     ZCL_STATUS_SUCCESS, pAlarm->code,
   3506                                                     pAlarm->clusterID, pAlarm->timeStamp,
   3507                                                     true, pInMsg->hdr.transSeqNum );
   3508                    // Remove the entry from the Alarm table
   3509                    zclGeneral_ResetAlarm( pInMsg->msg->endPoint, pAlarm->code, pAlarm->clusterID );
   3510                  }
   3511                  else
   3512                  {
   3513                    // Send a response back
   3514                    zclGeneral_SendAlarmGetResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   3515                                                     ZCL_STATUS_NOT_FOUND, 0, 0, 0,
   3516                                                     true, pInMsg->hdr.transSeqNum );
   3517                  }
   3518                  stat = ZCL_STATUS_CMD_HAS_RSP;
   3519                }
   3520                else
   3521                {
   3522                  stat = ZCL_STATUS_FAILURE;
   3523                }
   3524                break;
   3525          
   3526              case COMMAND_ALARMS_RESET_LOG:
   3527                if ( pCBs->pfnAlarm )
   3528                {
   3529                  alarm.cmdID = pInMsg->hdr.commandID;
   3530          
   3531                  pCBs->pfnAlarm( pInMsg->hdr.fc.direction, &alarm );
   3532          
   3533                  zclGeneral_ResetAllAlarms( pInMsg->msg->endPoint, FALSE );
   3534                }
   3535                else
   3536                {
   3537                  stat = ZCL_STATUS_FAILURE;
   3538                }
   3539                break;
   3540          
   3541          #ifdef SE_UK_EXT
   3542              case COMMAND_ALARMS_PUBLISH_EVENT_LOG:
   3543                if ( pCBs->pfnPublishEventLog )
   3544                {
   3545                  zclPublishEventLog_t eventLog;
   3546          
   3547                  eventLog.logID = *pData++;
   3548                  eventLog.cmdIndex = *pData++;
   3549                  eventLog.totalCmds = *pData++;
   3550          
   3551                  // First try to find out number of Sub Log Payloads
   3552                  eventLog.numSubLogs = (pInMsg->pDataLen-3)/(1+4); // event ID + event time
   3553                  if ( eventLog.numSubLogs > 0 )
   3554                  {
   3555                    // Try to alloc space for Log Payload
   3556                    eventLog.pLogs = (zclEventLogPayload_t *)zcl_mem_alloc( sizeof( zclEventLogPayload_t ) *
   3557                                                                             eventLog.numSubLogs );
   3558                    if ( eventLog.pLogs != NULL )
   3559                    {
   3560                      // Copy Log Payload
   3561                      for ( uint8 i = 0; i < eventLog.numSubLogs; i++ )
   3562                      {
   3563                        eventLog.pLogs[i].eventId = *pData++;
   3564                        eventLog.pLogs[i].eventTime = zcl_build_uint32( pData, 4 );
   3565                        pData += 4;
   3566                      }
   3567                    }
   3568                    else
   3569                    {
   3570                      stat = ZCL_STATUS_SOFTWARE_FAILURE;
   3571                    }
   3572                  }
   3573                  else
   3574                  {
   3575                    eventLog.pLogs = NULL;
   3576                  }
   3577          
   3578                  if ( stat == ZSuccess )
   3579                  {
   3580                    pCBs->pfnPublishEventLog( &(pInMsg->msg->srcAddr), &eventLog );
   3581                  }
   3582          
   3583                  if ( eventLog.pLogs != NULL )
   3584                  {
   3585                    zcl_mem_free( eventLog.pLogs );
   3586                  }
   3587                }
   3588                break;
   3589          #endif // SE_UK_EXT
   3590          
   3591              default:
   3592                stat = ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
   3593                break;
   3594            }
   3595          
   3596            return ( stat );
   3597          }
   3598          
   3599          /*********************************************************************
   3600           * @fn      zclGeneral_ProcessInAlarmsClient
   3601           *
   3602           * @brief   Process in the received Alarms Command.
   3603           *
   3604           * @param   pInMsg - pointer to the incoming message
   3605           *
   3606           * @return  ZStatus_t
   3607           */
   3608          static ZStatus_t zclGeneral_ProcessInAlarmsClient( zclIncoming_t *pInMsg,
   3609                                                             zclGeneral_AppCallbacks_t *pCBs )
   3610          {
   3611            uint8 *pData = pInMsg->pData;
   3612            zclAlarm_t alarm;
   3613            ZStatus_t stat = ZSuccess;
   3614          
   3615            zcl_memset( (uint8*)&alarm, 0, sizeof( zclAlarm_t ) );
   3616          
   3617            switch ( pInMsg->hdr.commandID )
   3618            {
   3619              case COMMAND_ALARMS_ALARM:
   3620                if ( pCBs->pfnAlarm )
   3621                {
   3622                  alarm.srcAddr = &(pInMsg->msg->srcAddr);
   3623                  alarm.cmdID = pInMsg->hdr.commandID;
   3624                  alarm.alarmCode = pData[0];
   3625                  alarm.clusterID = BUILD_UINT16( pData[1], pData[2] );
   3626          
   3627                  pCBs->pfnAlarm( pInMsg->hdr.fc.direction, &alarm );
   3628                }
   3629                else
   3630                {
   3631                  stat = ZCL_STATUS_FAILURE;
   3632                }
   3633                break;
   3634          
   3635              case COMMAND_ALARMS_GET_RSP:
   3636                if ( pCBs->pfnAlarm )
   3637                {
   3638                  alarm.srcAddr = &(pInMsg->msg->srcAddr);
   3639                  alarm.cmdID = pInMsg->hdr.commandID;
   3640                  alarm.alarmCode = *pData++;
   3641                  alarm.clusterID = BUILD_UINT16( pData[0], pData[1] );
   3642          
   3643                  pCBs->pfnAlarm( pInMsg->hdr.fc.direction, &alarm );
   3644                }
   3645                else
   3646                {
   3647                  stat = ZCL_STATUS_FAILURE;
   3648                }
   3649                break;
   3650          
   3651          #ifdef SE_UK_EXT
   3652              case COMMAND_ALARMS_GET_EVENT_LOG:
   3653                if ( pCBs->pfnGetEventLog )
   3654                {
   3655                  zclGetEventLog_t eventLog;
   3656          
   3657                  eventLog.logID = *pData++;
   3658                  eventLog.startTime = zcl_build_uint32( pData, 4 );
   3659                  pData += 4;
   3660                  eventLog.endTime = zcl_build_uint32( pData, 4 );
   3661                  pData += 4;
   3662                  eventLog.numEvents = *pData;
   3663          
   3664                  pCBs->pfnGetEventLog( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   3665                                        &eventLog, pInMsg->hdr.transSeqNum );
   3666                }
   3667                break;
   3668          #endif // SE_UK_EXT
   3669          
   3670              default:
   3671                stat = ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
   3672                break;
   3673            }
   3674          
   3675            return ( stat );
   3676          }
   3677          #endif // ZCL_ALARMS
   3678          
   3679          #ifdef ZCL_LOCATION
   3680          /*********************************************************************
   3681           * @fn      zclGeneral_ProcessInLocationServer
   3682           *
   3683           * @brief   Process in the received Location Command.
   3684           *
   3685           * @param   pInMsg - pointer to the incoming message
   3686           *
   3687           * @return  ZStatus_t
   3688           */
   3689          static ZStatus_t zclGeneral_ProcessInLocationServer( zclIncoming_t *pInMsg,
   3690                                                               zclGeneral_AppCallbacks_t *pCBs )
   3691          {
   3692            uint8 *pData = pInMsg->pData;
   3693            zclLocation_t cmd;
   3694            ZStatus_t stat = ZSuccess;
   3695          
   3696            zcl_memset( (uint8*)&cmd, 0, sizeof( zclLocation_t ) );
   3697          
   3698            switch ( pInMsg->hdr.commandID )
   3699            {
   3700              case COMMAND_LOCATION_SET_ABSOLUTE:
   3701                cmd.un.absLoc.coordinate1 = BUILD_UINT16( pData[0], pData[1] );
   3702                pData += 2;
   3703                cmd.un.absLoc.coordinate2 = BUILD_UINT16( pData[0], pData[1] );
   3704                pData += 2;
   3705                cmd.un.absLoc.coordinate3 = BUILD_UINT16( pData[0], pData[1] );
   3706                pData += 2;
   3707                cmd.un.absLoc.power = BUILD_UINT16( pData[0], pData[1] );
   3708                pData += 2;
   3709                cmd.un.absLoc.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   3710          
   3711                if ( pCBs->pfnLocation )
   3712                {
   3713                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   3714                  cmd.cmdID = pInMsg->hdr.commandID;
   3715          
   3716                  // Update the absolute location info
   3717                  pCBs->pfnLocation( &cmd );
   3718                }
   3719                break;
   3720          
   3721              case COMMAND_LOCATION_SET_DEV_CFG:
   3722                cmd.un.devCfg.power = BUILD_UINT16( pData[0], pData[1] );
   3723                pData += 2;
   3724                cmd.un.devCfg.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   3725                pData += 2;
   3726                cmd.un.devCfg.calcPeriod = BUILD_UINT16( pData[0], pData[1] );
   3727                pData += 2;
   3728                cmd.un.devCfg.numMeasurements = *pData++;
   3729                cmd.un.devCfg.reportPeriod = BUILD_UINT16( pData[0], pData[1] );
   3730          
   3731                if ( pCBs->pfnLocation )
   3732                {
   3733                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   3734                  cmd.cmdID = pInMsg->hdr.commandID;
   3735          
   3736                  // Update the device configuration info
   3737                  pCBs->pfnLocation( &cmd );
   3738                }
   3739                break;
   3740          
   3741              case COMMAND_LOCATION_GET_DEV_CFG:
   3742                cmd.un.ieeeAddr = pData;
   3743          
   3744                if ( pCBs->pfnLocation )
   3745                {
   3746                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   3747                  cmd.cmdID = pInMsg->hdr.commandID;
   3748                  cmd.seqNum = pInMsg->hdr.transSeqNum;
   3749          
   3750                  // Retreive the Device Configuration
   3751                  pCBs->pfnLocation( &cmd );
   3752                }
   3753                stat = ZCL_STATUS_CMD_HAS_RSP;
   3754                break;
   3755          
   3756              case COMMAND_LOCATION_GET_DATA:
   3757                cmd.un.loc.bitmap.locByte = *pData++;
   3758                cmd.un.loc.numResponses = *pData++;
   3759          
   3760                if ( cmd.un.loc.brdcastResponse == 0 ) // command is sent as a unicast
   3761                  zcl_memcpy( cmd.un.loc.targetAddr, pData, 8 );
   3762          
   3763                if ( pCBs->pfnLocation )
   3764                {
   3765                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   3766                  cmd.cmdID = pInMsg->hdr.commandID;
   3767                  cmd.seqNum = pInMsg->hdr.transSeqNum;
   3768          
   3769                  // Retreive the Location Data
   3770                  pCBs->pfnLocation( &cmd );
   3771                }
   3772                stat = ZCL_STATUS_CMD_HAS_RSP;
   3773                break;
   3774          
   3775              default:
   3776                stat = ZFailure;
   3777                break;
   3778            }
   3779          
   3780            return ( stat );
   3781          }
   3782          
   3783          /*********************************************************************
   3784           * @fn      zclGeneral_ProcessInLocationDataRsp
   3785           *
   3786           * @brief   Process in the received Location Command.
   3787           *
   3788           * @param   pInMsg - pointer to the incoming message
   3789           *
   3790           * @return  ZStatus_t
   3791           */
   3792          static void zclGeneral_ProcessInLocationDataRsp( zclIncoming_t *pInMsg,
   3793                                                           zclGeneral_AppCallbacks_t *pCBs )
   3794          {
   3795            uint8 *pData = pInMsg->pData;
   3796            zclLocationRsp_t rsp;
   3797          
   3798            zcl_memset( (uint8*)&rsp, 0, sizeof( zclLocationRsp_t ) );
   3799          
   3800            if ( pCBs->pfnLocationRsp )
   3801            {
   3802              if ( pInMsg->hdr.commandID == COMMAND_LOCATION_DATA_RSP )
   3803                rsp.un.loc.status = *pData++;
   3804          
   3805              if ( pInMsg->hdr.commandID != COMMAND_LOCATION_DATA_RSP ||
   3806                   rsp.un.loc.status == ZCL_STATUS_SUCCESS )
   3807              {
   3808                rsp.un.loc.data.type = *pData++;
   3809                rsp.un.loc.data.absLoc.coordinate1 = BUILD_UINT16( pData[0], pData[1] );
   3810                pData += 2;
   3811                rsp.un.loc.data.absLoc.coordinate2 = BUILD_UINT16( pData[0], pData[1] );
   3812                pData += 2;
   3813          
   3814                if ( locationType2D( rsp.un.loc.data.type ) == 0 )
   3815                {
   3816                  rsp.un.loc.data.absLoc.coordinate3 = BUILD_UINT16( pData[0], pData[1] );
   3817                  pData += 2;
   3818                }
   3819          
   3820                if ( pInMsg->hdr.commandID != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   3821                {
   3822                  rsp.un.loc.data.absLoc.power = BUILD_UINT16( pData[0], pData[1] );
   3823                  pData += 2;
   3824                  rsp.un.loc.data.absLoc.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   3825                  pData += 2;
   3826                }
   3827          
   3828                if ( locationTypeAbsolute( rsp.un.loc.data.type ) == 0 )
   3829                {
   3830                  if ( pInMsg->hdr.commandID != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   3831                    rsp.un.loc.data.calcLoc.locationMethod = *pData++;
   3832          
   3833                  rsp.un.loc.data.calcLoc.qualityMeasure = *pData++;
   3834                  rsp.un.loc.data.calcLoc.locationAge = BUILD_UINT16( pData[0], pData[1] );
   3835                }
   3836              }
   3837          
   3838              rsp.srcAddr = &(pInMsg->msg->srcAddr);
   3839              rsp.cmdID = pInMsg->hdr.commandID;
   3840          
   3841              // Notify the Application
   3842              pCBs->pfnLocationRsp( &rsp );
   3843            }
   3844          }
   3845          
   3846          /*********************************************************************
   3847           * @fn      zclGeneral_ProcessInLocationClient
   3848           *
   3849           * @brief   Process in the received Location Command.
   3850           *
   3851           * @param   pInMsg - pointer to the incoming message
   3852           *
   3853           * @return  ZStatus_t
   3854           */
   3855          static ZStatus_t zclGeneral_ProcessInLocationClient( zclIncoming_t *pInMsg,
   3856                                                               zclGeneral_AppCallbacks_t *pCBs )
   3857          {
   3858            uint8 *pData = pInMsg->pData;
   3859            zclLocationRsp_t rsp;
   3860            ZStatus_t stat = ZSuccess;
   3861          
   3862            zcl_memset( (uint8*)&rsp, 0, sizeof( zclLocationRsp_t ) );
   3863          
   3864            switch ( pInMsg->hdr.commandID )
   3865            {
   3866              case COMMAND_LOCATION_DEV_CFG_RSP:
   3867                if ( pCBs->pfnLocationRsp )
   3868                {
   3869                  rsp.un.devCfg.status = *pData++;
   3870                  if ( rsp.un.devCfg.status == ZCL_STATUS_SUCCESS )
   3871                  {
   3872                    rsp.un.devCfg.data.power = BUILD_UINT16( pData[0], pData[1] );
   3873                    pData += 2;
   3874                    rsp.un.devCfg.data.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   3875                    pData += 2;
   3876                    rsp.un.devCfg.data.calcPeriod = BUILD_UINT16( pData[0], pData[1] );
   3877                    pData += 2;
   3878                    rsp.un.devCfg.data.numMeasurements = *pData++;
   3879                    rsp.un.devCfg.data.reportPeriod = BUILD_UINT16( pData[0], pData[1] );
   3880          
   3881                    rsp.srcAddr = &(pInMsg->msg->srcAddr);
   3882                    rsp.cmdID = pInMsg->hdr.commandID;
   3883          
   3884                    // Notify the Application
   3885                    pCBs->pfnLocationRsp( &rsp );
   3886                  }
   3887                }
   3888                break;
   3889          
   3890              case COMMAND_LOCATION_DATA_RSP:
   3891              case COMMAND_LOCATION_DATA_NOTIF:
   3892              case COMMAND_LOCATION_COMPACT_DATA_NOTIF:
   3893                zclGeneral_ProcessInLocationDataRsp( pInMsg, pCBs );
   3894                break;
   3895          
   3896              case COMMAND_LOCATION_RSSI_PING:
   3897                if ( pCBs->pfnLocationRsp )
   3898                {
   3899                  rsp.un.locationType = *pData;
   3900          
   3901                  rsp.srcAddr = &(pInMsg->msg->srcAddr);
   3902                  rsp.cmdID = pInMsg->hdr.commandID;
   3903          
   3904                  // Notify the Application
   3905                  pCBs->pfnLocationRsp( &rsp );
   3906                }
   3907                break;
   3908          
   3909              default:
   3910                stat = ZFailure;
   3911                break;
   3912            }
   3913          
   3914            return ( stat );
   3915          }
   3916          #endif // ZCL_LOCATION
   3917          
   3918          #ifdef ZCL_SCENES
   3919          #if !defined ( ZCL_STANDALONE )
   3920          /*********************************************************************
   3921           * @fn      zclGeneral_ScenesInitNV
   3922           *
   3923           * @brief   Initialize the NV Scene Table Items
   3924           *
   3925           * @param   none
   3926           *
   3927           * @return  number of scenes
   3928           */
   3929          static uint8 zclGeneral_ScenesInitNV( void )
   3930          {
   3931            uint8  status;
   3932            uint16 size;
   3933          
   3934            size = (uint16)((sizeof ( nvGenScenesHdr_t ))
   3935                            + ( sizeof( zclGenSceneNVItem_t ) * ZCL_GEN_MAX_SCENES ));
   3936          
   3937            status = zcl_nv_item_init( ZCD_NV_SCENE_TABLE, size, NULL );
   3938          
   3939            if ( status != ZSUCCESS )
   3940            {
   3941              zclGeneral_ScenesSetDefaultNV();
   3942            }
   3943          
   3944            return status;
   3945          }
   3946          #endif // ZCL_STANDALONE
   3947          
   3948          #if !defined ( ZCL_STANDALONE )
   3949          /*********************************************************************
   3950           * @fn          zclGeneral_ScenesSetDefaultNV
   3951           *
   3952           * @brief       Write the defaults to NV
   3953           *
   3954           * @param       none
   3955           *
   3956           * @return      none
   3957           */
   3958          static void zclGeneral_ScenesSetDefaultNV( void )
   3959          {
   3960            nvGenScenesHdr_t hdr;
   3961          
   3962            // Initialize the header
   3963            hdr.numRecs = 0;
   3964          
   3965            // Save off the header
   3966            zcl_nv_write( ZCD_NV_SCENE_TABLE, 0, sizeof( nvGenScenesHdr_t ), &hdr );
   3967          }
   3968          #endif // ZCL_STANDALONE
   3969          
   3970          #if !defined ( ZCL_STANDALONE )
   3971          /*********************************************************************
   3972           * @fn          zclGeneral_ScenesWriteNV
   3973           *
   3974           * @brief       Save the Scene Table in NV
   3975           *
   3976           * @param       none
   3977           *
   3978           * @return      none
   3979           */
   3980          static void zclGeneral_ScenesWriteNV( void )
   3981          {
   3982            nvGenScenesHdr_t hdr;
   3983            zclGenSceneItem_t *pLoop;
   3984            zclGenSceneNVItem_t item;
   3985          
   3986            hdr.numRecs = 0;
   3987          
   3988            // Look for end of list
   3989            pLoop = zclGenSceneTable;
   3990            while ( pLoop )
   3991            {
   3992              // Build the record
   3993              item.endpoint = pLoop->endpoint;
   3994              zcl_memcpy( &(item.scene), &(pLoop->scene), sizeof ( zclGeneral_Scene_t ) );
   3995          
   3996              // Save the record to NV
   3997              zcl_nv_write( ZCD_NV_SCENE_TABLE,
   3998                      (uint16)((sizeof( nvGenScenesHdr_t )) + (hdr.numRecs * sizeof ( zclGenSceneNVItem_t ))),
   3999                              sizeof ( zclGenSceneNVItem_t ), &item );
   4000          
   4001              hdr.numRecs++;
   4002          
   4003              pLoop = pLoop->next;
   4004            }
   4005          
   4006            // Save off the header
   4007            zcl_nv_write( ZCD_NV_SCENE_TABLE, 0, sizeof( nvGenScenesHdr_t ), &hdr );
   4008          }
   4009          #endif // ZCL_STANDALONE
   4010          
   4011          #if !defined ( ZCL_STANDALONE )
   4012          /*********************************************************************
   4013           * @fn          zclGeneral_ScenesRestoreFromNV
   4014           *
   4015           * @brief       Restore the Scene table from NV
   4016           *
   4017           * @param       none
   4018           *
   4019           * @return      Number of entries restored
   4020           */
   4021          static uint16 zclGeneral_ScenesRestoreFromNV( void )
   4022          {
   4023            uint16 x;
   4024            nvGenScenesHdr_t hdr;
   4025          
   4026            zclGenSceneNVItem_t item;
   4027            uint16 numAdded = 0;
   4028          
   4029            if ( zcl_nv_read( ZCD_NV_SCENE_TABLE, 0, sizeof(nvGenScenesHdr_t), &hdr ) == ZSuccess )
   4030            {
   4031              // Read in the device list
   4032              for ( x = 0; x < hdr.numRecs; x++ )
   4033              {
   4034                if ( zcl_nv_read( ZCD_NV_SCENE_TABLE,
   4035                          (uint16)(sizeof(nvGenScenesHdr_t) + (x * sizeof ( zclGenSceneNVItem_t ))),
   4036                                            sizeof ( zclGenSceneNVItem_t ), &item ) == ZSUCCESS )
   4037                {
   4038                  // Add the scene
   4039                  if ( zclGeneral_AddScene( item.endpoint, &(item.scene) ) == ZSuccess )
   4040                  {
   4041                    numAdded++;
   4042                  }
   4043                }
   4044              }
   4045            }
   4046          
   4047            return ( numAdded );
   4048          }
   4049          #endif // ZCL_STANDALONE
   4050          
   4051          #if !defined ( ZCL_STANDALONE )
   4052          /*********************************************************************
   4053           * @fn          zclGeneral_ScenesInit
   4054           *
   4055           * @brief       Initialize the scenes table
   4056           *
   4057           * @param       none
   4058           *
   4059           * @return      none
   4060           */
   4061          void zclGeneral_ScenesInit( void )
   4062          {
   4063            // Initialize NV items
   4064            zclGeneral_ScenesInitNV();
   4065          
   4066            // Restore the Scene table
   4067            zclGeneral_ScenesRestoreFromNV();
   4068          }
   4069          #endif // ZCL_STANDALONE
   4070          
   4071          #if !defined ( ZCL_STANDALONE )
   4072          /*********************************************************************
   4073           * @fn          zclGeneral_ScenesSave
   4074           *
   4075           * @brief       Save the scenes table
   4076           *
   4077           * @param       none
   4078           *
   4079           * @return      none
   4080           */
   4081          void zclGeneral_ScenesSave( void )
   4082          {
   4083            // Update NV
   4084            zclGeneral_ScenesWriteNV();
   4085          }
   4086          #endif // ZCL_STANDALONE
   4087          
   4088          #endif // ZCL_SCENES
   4089          
   4090          /***************************************************************************
   4091          ****************************************************************************/

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      0     10   zclGeneral_HdlInSpecificCommands
      2      0   zclGeneral_HdlIncoming
        2      0   -> zclGeneral_HdlInSpecificCommands
      1     14   zclGeneral_RegisterCmdCallbacks
        0     12   -> osal_mem_alloc
        0     14   -> zcl_registerPlugin


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      14  ?Subroutine0
       7  ?Subroutine1
       2  zclGenCBs
       1  zclGenPluginRegisted
     214  zclGeneral_HdlInSpecificCommands
       6  zclGeneral_HdlInSpecificCommands::?relay
      33  zclGeneral_HdlIncoming
       6  zclGeneral_HdlIncoming::?relay
     156  zclGeneral_RegisterCmdCallbacks
       6  zclGeneral_RegisterCmdCallbacks::?relay

 
 424 bytes in segment BANKED_CODE
  18 bytes in segment BANK_RELAYS
   3 bytes in segment XDATA_Z
 
  18 bytes of CODE     memory
 424 bytes of HUGECODE memory
   3 bytes of XDATA    memory

Errors: none
Warnings: none
